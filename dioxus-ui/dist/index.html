<!DOCTYPE html>
<html class="dark">
    <head>
        <meta charset="utf-8" />
        <title>videocall.rs (Dioxus)</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        
        
<script type="module">
import init, * as bindings from '/dioxus-ui-ff126e213da065ba.js';
const wasm = await init({ module_or_path: '/dioxus-ui-ff126e213da065ba_bg.wasm' });


window.wasmBindings = bindings;


dispatchEvent(new CustomEvent("TrunkApplicationStarted", {detail: {wasm}}));

</script>
        <link rel="stylesheet" href="/leptos-style-803f01429327104.css" integrity="sha384-aZsPb3tvD1RgEILNNoq3BHZuRbJZwI0ZGrbpPOxg6SwHz0GLQJelNYdVuAsZs/T8"/>
        <link rel="stylesheet" href="/tailwind-659406adf03bc292.css" integrity="sha384-zDDTKtQ7gowl2/ORJoRNVdD+WxxqSuZ4JMcucpiJqGAfmuLMIxYFO/N4ZgkCH06U"/>
        <link rel="stylesheet" href="/style-7867086c14ce63a7.css" integrity="sha384-Cd99GYQX7JT4wQGzwPbegSI6qXf4qC4vbudd7cBGv/DA/RzxkPiBAFJU3TCXS/rf"/>
        <link rel="stylesheet" href="/global-8fa9326d44a5a202.css" integrity="sha384-dCwiw00abNanso+liIjlvrdSTNOnZaOGkAeWO8Kr+q9RRYTsCIG9wXQDZe/IGoZb"/>
        
        
        <!-- TOFIX: these files are not being hashed correctly, so they are not being cached -->
        
        
        <script src="/config.js"></script>
        <!-- Compile videocall-codecs's `worker.rs` as a separate WASM module for WebCodecs -->
        
        <!-- Runtime link so the wasm decoder can find the built worker URL -->
        <link id="codecs-worker" href="/worker_decoder_loader.js" />
        <!-- NetEq worker -->
        
        <link id="neteq-worker" href="/neteq_worker_loader.js" />

        <!-- Load wasm worker scripts from the videocall-codecs crate -->
        <!-- MediaStreamTrackProcessor polyfill using LiveKit's approach:
             Creates VideoFrame directly from video element instead of canvas copy.
             See: https://github.com/livekit/track-processors-js/pull/65 -->
        <script>
            if (!self.MediaStreamTrackProcessor) {
            self.MediaStreamTrackProcessor = class MediaStreamTrackProcessor {
                constructor({track}) {
                if (track.kind == "video") {
                    this.readable = new ReadableStream({
                    async start(controller) {
                        this.video = document.createElement("video");
                        this.video.muted = true;
                        this.video.srcObject = new MediaStream([track]);
                        await Promise.all([
                            this.video.play(),
                            new Promise(r => this.video.onloadedmetadata = r)
                        ]);
                        this.track = track;

                        if (!this.video.videoWidth || !this.video.videoHeight) {
                            console.warn("Video dimensions not available after metadata load");
                        }

                        // Try direct VideoFrame from video element (LiveKit approach)
                        const supportsDirectVideoFrame = (() => {
                            try {
                                const testFrame = new VideoFrame(this.video);
                                testFrame.close();
                                return true;
                            } catch (e) {
                                return false;
                            }
                        })();

                        if (supportsDirectVideoFrame) {
                            console.log("Using direct VideoFrame(video) - LiveKit approach");

                            let lastVideoTime = -1;

                            if (this.video.requestVideoFrameCallback) {
                                console.log("Using requestVideoFrameCallback with direct VideoFrame");
                                const processFrame = (now, metadata) => {
                                    if (!controller.desiredSize) {
                                        this.video?.pause();
                                        return;
                                    }

                                    const currentTime = this.video.currentTime;
                                    if (currentTime !== lastVideoTime) {
                                        lastVideoTime = currentTime;
                                        try {
                                            const frame = new VideoFrame(this.video, {
                                                timestamp: metadata.mediaTime * 1e6
                                            });
                                            controller.enqueue(frame);
                                        } catch (e) {
                                            console.error("Error creating VideoFrame:", e);
                                        }
                                    }

                                    if (controller.desiredSize > 0) {
                                        this.video.requestVideoFrameCallback(processFrame);
                                    }
                                };
                                this.video.requestVideoFrameCallback(processFrame);
                            } else {
                                console.warn("Using requestAnimationFrame with direct VideoFrame");
                                let lastTimestamp = -1;
                                const processFrameRAF = (timestamp) => {
                                    if (!controller.desiredSize) {
                                        this.video?.pause();
                                        return;
                                    }

                                    const currentTime = this.video.currentTime;
                                    if (currentTime !== lastVideoTime && timestamp !== lastTimestamp) {
                                        lastVideoTime = currentTime;
                                        lastTimestamp = timestamp;
                                        try {
                                            const frame = new VideoFrame(this.video, {
                                                timestamp: performance.now() * 1000
                                            });
                                            controller.enqueue(frame);
                                        } catch (e) {
                                            console.error("Error creating VideoFrame:", e);
                                        }
                                    }

                                    if (controller.desiredSize > 0) {
                                        requestAnimationFrame(processFrameRAF);
                                    }
                                };
                                requestAnimationFrame(processFrameRAF);
                            }
                        } else {
                            console.log("Using canvas-based polyfill (direct VideoFrame not supported)");
                            this.canvas = new OffscreenCanvas(
                                this.video.videoWidth || 640,
                                this.video.videoHeight || 480
                            );
                            this.ctx = this.canvas.getContext('2d', {desynchronized: true});

                            if (this.video.requestVideoFrameCallback) {
                                const processFrame = (now, metadata) => {
                                    if (!controller.desiredSize) return;
                                    try {
                                        if (this.video.videoWidth && this.video.videoHeight) {
                                            if (this.canvas.width !== this.video.videoWidth ||
                                                this.canvas.height !== this.video.videoHeight) {
                                                this.canvas.width = this.video.videoWidth;
                                                this.canvas.height = this.video.videoHeight;
                                            }
                                            this.ctx.drawImage(this.video, 0, 0);
                                            controller.enqueue(new VideoFrame(this.canvas, {
                                                timestamp: metadata.mediaTime * 1e6
                                            }));
                                        }
                                    } catch (e) {
                                        console.error("Error processing video frame:", e);
                                    }
                                    if (controller.desiredSize > 0) {
                                        this.video.requestVideoFrameCallback(processFrame);
                                    } else {
                                        this.video?.pause();
                                    }
                                };
                                this.video.requestVideoFrameCallback(processFrame);
                            } else {
                                let lastTimestamp = -1;
                                const processFrameRAF = (timestamp) => {
                                    if (!controller.desiredSize) {
                                        this.video?.pause();
                                        return;
                                    }
                                    if (timestamp !== lastTimestamp) {
                                        lastTimestamp = timestamp;
                                        try {
                                            if (this.video.videoWidth && this.video.videoHeight) {
                                                if (this.canvas.width !== this.video.videoWidth ||
                                                    this.canvas.height !== this.video.videoHeight) {
                                                    this.canvas.width = this.video.videoWidth;
                                                    this.canvas.height = this.video.videoHeight;
                                                }
                                                this.ctx.drawImage(this.video, 0, 0);
                                                controller.enqueue(new VideoFrame(this.canvas, {
                                                    timestamp: performance.now() * 1000
                                                }));
                                            }
                                        } catch (e) {
                                            console.error("Error processing video frame:", e);
                                        }
                                    }
                                    if (controller.desiredSize > 0) {
                                        requestAnimationFrame(processFrameRAF);
                                    }
                                };
                                requestAnimationFrame(processFrameRAF);
                            }
                        }
                    },
                    cancel(reason) {
                        console.log("Video track processor cancelled:", reason);
                        if (this.video) {
                            this.video.pause();
                            this.video.srcObject = null;
                        }
                    }
                    });
                } else if (track.kind == "audio") {
                    this.readable = new ReadableStream({
                    async start(controller) {
                        this.ac = new AudioContext;
                        this.arrays = [];
                        function worklet() {
                        registerProcessor("mstp-shim", class Processor extends AudioWorkletProcessor {
                            process(input) { this.port.postMessage(input); return true; }
                        });
                        }
                        await this.ac.audioWorklet.addModule(`data:text/javascript,(${worklet.toString()})()`);
                        this.node = new AudioWorkletNode(this.ac, "mstp-shim");
                        this.ac.createMediaStreamSource(new MediaStream([track])).connect(this.node);
                        this.node.port.addEventListener("message", ({data}) => data[0][0] && this.arrays.push(data));
                    },
                    async pull(controller) {
                        while (!this.arrays.length) await new Promise(r => this.node.port.onmessage = r);
                        const [channels] = this.arrays.shift();
                        const joined = new Float32Array(channels.reduce((a, b) => a + b.length, 0));
                        channels.reduce((offset, a) => (joined.set(a, offset), offset + a.length), 0);
                        controller.enqueue(new AudioData({
                        format: "f32-planar",
                        sampleRate: this.ac.sampleRate,
                        numberOfFrames: channels[0].length,
                        numberOfChannels: channels.length,
                        timestamp: this.ac.currentTime * 1e6 | 0,
                        data: joined,
                        transfer: [joined.buffer]
                        }));
                    }
                    });
                }
                }
            };
            }
        </script>
        <!-- MediaStreamTrackGenerator polyfill -->
        <script>
            if (!window.MediaStreamTrackGenerator) {
            window.MediaStreamTrackGenerator = class MediaStreamTrackGenerator {
                constructor({kind}) {
                if (kind == "video") {
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext('2d', {desynchronized: true});
                    const track = canvas.captureStream().getVideoTracks()[0];
                    track.writable = new WritableStream({
                    write(frame) {
                        canvas.width = frame.displayWidth;
                        canvas.height = frame.displayHeight;
                        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
                        frame.close();
                    }
                    });
                    return track;
                } else if (kind == "audio") {
                    const ac = new AudioContext;
                    const dest = ac.createMediaStreamDestination();
                    const [track] = dest.stream.getAudioTracks();
                    track.writable = new WritableStream({
                    async start(controller) {
                        this.arrays = [];
                        function worklet() {
                        registerProcessor("mstg-shim", class Processor extends AudioWorkletProcessor {
                            constructor() {
                            super();
                            this.arrays = [];
                            this.arrayOffset = 0;
                            this.port.onmessage = ({data}) => this.arrays.push(data);
                            this.emptyArray = new Float32Array(0);
                            }
                            process(inputs, [[output]]) {
                            for (let i = 0; i < output.length; i++) {
                                if (!this.array || this.arrayOffset >= this.array.length) {
                                this.array = this.arrays.shift() || this.emptyArray;
                                this.arrayOffset = 0;
                                }
                                output[i] = this.array[this.arrayOffset++] || 0;
                            }
                            return true;
                            }
                        });
                        }
                        await ac.audioWorklet.addModule(`data:text/javascript,(${worklet.toString()})()`);
                        this.node = new AudioWorkletNode(ac, "mstg-shim");
                        this.node.connect(dest);
                        return track;
                    },
                    write(audioData) {
                        const array = new Float32Array(audioData.numberOfFrames * audioData.numberOfChannels);
                        audioData.copyTo(array, {planeIndex: 0});
                        this.node.port.postMessage(array, [array.buffer]);
                        audioData.close();
                    }
                    });
                    return track;
                }
                }
            };
            }
        </script>
    <link rel="modulepreload" href="/dioxus-ui-ff126e213da065ba.js" crossorigin="anonymous" integrity="sha384-EW3fklEKpt7iCeC4cYO/qqXB/Nv2i7tLACq07rpH+iQswqQwpCEVTCGT9IVFbHEz"><link rel="modulepreload" href="/snippets/dioxus-web-afdd4c4e5aff9d11/inline0.js" crossorigin="anonymous" integrity="sha384-2v8X0XAeO26J0vmoLhIbIeAjVzFnrY9iLhlYJcksTMp7Ip2tbDcoX4vD/hCan7M7"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-c0f0333193e32f17/inline0.js" crossorigin="anonymous" integrity="sha384-j0LKwUivj+3TJqebf9mBv6v1Yu2sX+LAJanOVfQAVOZpWTU0+pzzo8XExJBFDUso"><link rel="modulepreload" href="/snippets/dioxus-web-bf44d47c344f35d0/src/js/eval.js" crossorigin="anonymous" integrity="sha384-2DHjVGrzcpbms06h5LAGWYB1zXEqfWTjATq1YsBBgX1CE2W+T4mRjoljwlXKhTcj"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-53424282ea002554/src/js/patch_console.js" crossorigin="anonymous" integrity="sha384-5JBHRbmtlt+1itRKLdoRs4hjdIQ0pUfmNhwtAJCq+u7x+x3KJJzzps279xv7KZFv"><link rel="modulepreload" href="/snippets/dioxus-web-bf44d47c344f35d0/inline0.js" crossorigin="anonymous" integrity="sha384-2v8X0XAeO26J0vmoLhIbIeAjVzFnrY9iLhlYJcksTMp7Ip2tbDcoX4vD/hCan7M7"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-53424282ea002554/src/js/hydrate.js" crossorigin="anonymous" integrity="sha384-pfz3GoOS0du3Se5f5C1lkvbvMo0g507e24Rcu0dm29CmSCqxguUw3chk5PS1brtF"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-c0f0333193e32f17/src/js/set_attribute.js" crossorigin="anonymous" integrity="sha384-KzHUe16NLJR2eaeVyqeB7zwb1qHGH3sV/aw0aS7V/+IeQwWH6OAnZ9nbGkwEyGzZ"><link rel="modulepreload" href="/snippets/dioxus-cli-config-8d0dd142fb491fe2/inline0.js" crossorigin="anonymous" integrity="sha384-63GOaGGIhEHCB9m4vzzYEBfUIIUWiAYuNlk/LB2TuDDcjK13LO2II01K9xxO0fFG"><link rel="modulepreload" href="/snippets/dioxus-cli-config-24e80746d3c500cd/inline0.js" crossorigin="anonymous" integrity="sha384-63GOaGGIhEHCB9m4vzzYEBfUIIUWiAYuNlk/LB2TuDDcjK13LO2II01K9xxO0fFG"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-c0f0333193e32f17/src/js/hydrate.js" crossorigin="anonymous" integrity="sha384-Ocp9HYCb7T7M2KNri/Y2CHx/JgjlahEvu2KUTc/YKyGLB0s0pgNeCaanjX7egjMz"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-53424282ea002554/src/js/common.js" crossorigin="anonymous" integrity="sha384-lNXbLTw7Z18z5HtM0HV3R7/8J+II5Ei18I53QeIZolR+l1nGEBr27UjMtT/DJpiC"><link rel="modulepreload" href="/snippets/dioxus-web-bf44d47c344f35d0/inline1.js" crossorigin="anonymous" integrity="sha384-xqSmg18C2FmchYWi9fb4cSqOW4ZNNo4b7NWZK1eW+fOqg4no+2F+zETwKUf1PJy3"><link rel="modulepreload" href="/snippets/dioxus-web-afdd4c4e5aff9d11/src/js/eval.js" crossorigin="anonymous" integrity="sha384-p8SsdRWHMmi6kI0ok6n5NV3mpIQPM5rkaJiiTwobcDIXKNhvajvPCqsBACIQVcP8"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-c0f0333193e32f17/src/js/patch_console.js" crossorigin="anonymous" integrity="sha384-r+5veWcnM6yFNXixia5X8SIr1KdMZfaSc4dp0/8fqFpt3s6gK4zUXXSkvHdZ4TmG"><link rel="modulepreload" href="/snippets/dioxus-interpreter-js-53424282ea002554/inline0.js" crossorigin="anonymous" integrity="sha384-E7XrAE0tjDaRj+uif7xg0rIvO4VMl9KbHNgq94n8VQaTlxijO4YyNOEWxo5jD9IU"><link rel="preload" href="/dioxus-ui-ff126e213da065ba_bg.wasm" crossorigin="anonymous" integrity="sha384-faignXYHj/a2mLAWQ2DknUwR5Z7RZW9mmWe8rKzoYXnBtXa1+F1Qg4alUYWQcGz0" as="fetch" type="application/wasm"></head>
    <body class="bg-background text-foreground">
        <div id="main"></div>
    <script>"use strict";

(function () {

    const address = '{{__TRUNK_ADDRESS__}}';
    const base = '{{__TRUNK_WS_BASE__}}';
    let protocol = '';
    protocol =
        protocol
            ? protocol
            : window.location.protocol === 'https:'
                ? 'wss'
                : 'ws';
    const url = protocol + '://' + address + base + '.well-known/trunk/ws';

    class Overlay {
        constructor() {
            // create an overlay
            this._overlay = document.createElement("div");
            const style = this._overlay.style;
            style.height = "100vh";
            style.width = "100vw";
            style.position = "fixed";
            style.top = "0";
            style.left = "0";
            style.backgroundColor = "rgba(222, 222, 222, 0.5)";
            style.fontFamily = "sans-serif";
            // not sure that's the right approach
            style.zIndex = "1000000";
            style.backdropFilter = "blur(1rem)";

            const container = document.createElement("div");
            // center it
            container.style.position = "absolute";
            container.style.top = "30%";
            container.style.left = "15%";
            container.style.maxWidth = "85%";

            this._title = document.createElement("div");
            this._title.innerText = "Build failure";
            this._title.style.paddingBottom = "2rem";
            this._title.style.fontSize = "2.5rem";

            this._message = document.createElement("div");
            this._message.style.whiteSpace = "pre-wrap";

            const icon= document.createElement("div");
            icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="#dc3545" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>';
            this._title.prepend(icon);

            container.append(this._title, this._message);
            this._overlay.append(container);

            this._inject();
            window.setInterval(() => {
                this._inject();
            }, 250);
        }

        set reason(reason) {
            this._message.textContent = reason;
        }

        _inject() {
            if (!this._overlay.isConnected) {
                // prepend it
                document.body?.prepend(this._overlay);
            }
        }

    }

    class Client {
        constructor(url) {
            this.url = url;
            this.poll_interval = 5000;
            this._overlay = null;
        }

        start() {
            const ws = new WebSocket(this.url);
            ws.onmessage = (ev) => {
                const msg = JSON.parse(ev.data);
                switch (msg.type) {
                    case "reload":
                        this.reload();
                        break;
                    case "buildFailure":
                        this.buildFailure(msg.data)
                        break;
                }
            };
            ws.onclose = () => this.onclose();
        }

        onclose() {
            window.setTimeout(
                () => {
                    // when we successfully reconnect, we'll force a
                    // reload (since we presumably lost connection to
                    // trunk due to it being killed, so it will have
                    // rebuilt on restart)
                    const ws = new WebSocket(this.url);
                    ws.onopen = () => window.location.reload();
                    ws.onclose = () => this.onclose();
                },
                this.poll_interval);
        }

        reload() {
            window.location.reload();
        }

        buildFailure({reason}) {
            // also log the console
            console.error("Build failed:", reason);

            console.debug("Overlay", this._overlay);

            if (!this._overlay) {
                this._overlay = new Overlay();
            }
            this._overlay.reason = reason;
        }
    }

    new Client(url).start();

})()
</script></body>
</html>
