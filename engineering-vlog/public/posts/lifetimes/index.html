<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         You'll Finally Understand Lifetimes in Rust After Read This
        
    </title><meta content="You'll Finally Understand Lifetimes in Rust After Read This" property=og:title><meta content="Videocall Engineering" property=og:description><meta content="Videocall Engineering" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://engineering.videocall.rs/fonts.css rel=stylesheet><link title="Videocall Engineering" href=https://engineering.videocall.rs/atom.xml rel=alternate type=application/atom+xml><link href=https://engineering.videocall.rs/theme/light.css rel=stylesheet><link href=https://engineering.videocall.rs/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://engineering.videocall.rs/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://engineering.videocall.rs/main.css media=screen rel=stylesheet><script data-cf-beacon='{"token": "37a0f981a37240aea00b781e300bc6c0"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script></head><script>// Function to set the theme
        function setTheme(theme) {
            document.documentElement.className = theme;
            localStorage.setItem('theme', theme);
        }

        // Function to get the saved theme
        function getSavedTheme() {
            return localStorage.getItem('theme') || 'light';
        }

        // Set the theme on page load
        document.addEventListener('DOMContentLoaded', (event) => {
            setTheme(getSavedTheme());
        });</script><body><div class=content><header><div class=main><a href=https://engineering.videocall.rs>Videocall Engineering</a><div class=socials><a class=social href=https://twitter.com/emportent rel=me> <img alt=x src=https://engineering.videocall.rs/social_icons/x.svg> </a><a class=social href=https://github.com/altunenes rel=me> <img alt=github src=https://engineering.videocall.rs/social_icons/github.svg> </a><a href="https://scholar.google.com/citations?user=_OtEw5oAAAAJ&hl" class=social rel=me> <img alt=scholar src=https://engineering.videocall.rs/social_icons/googlescholar.svg> </a><a class=social href=https://www.linkedin.com/in/enes-altun-0a3076167 rel=me> <img alt=linkedin src=https://engineering.videocall.rs/social_icons/linkedin.svg> </a><a class=social href=https://www.instagram.com/altunanes/ rel=me> <img alt=instagram src=https://engineering.videocall.rs/social_icons/instagram.svg> </a><a class=social href=https://orcid.org/0000-0002-6478-6909 rel=me> <img alt=orcid src=https://engineering.videocall.rs/social_icons/orcid.svg> </a><a class=social href=https://www.shadertoy.com/user/altunenes rel=me> <img alt=shadertoy src=https://engineering.videocall.rs/social_icons/shadertoy.svg> </a><a class=social href=https://bsky.app/profile/altunenes.bsky.social rel=me> <img alt=bluesky src=https://engineering.videocall.rs/social_icons/bluesky.svg> </a></div></div><nav><a href=https://engineering.videocall.rs/posts style=margin-left:.7em>/posts</a><a href=https://engineering.videocall.rs/projects style=margin-left:.7em>/projects</a><a href=https://engineering.videocall.rs/about style=margin-left:.7em>/about</a><a href=https://engineering.videocall.rs/tags style=margin-left:.7em>/tags</a><a href=https://engineering.videocall.rs/CV style=margin-left:.7em>/CV</a><button aria-label="Toggle dark mode" id=dark-mode-toggle onclick=toggleTheme();><img alt="Light mode" id=sun-icon src=https://engineering.videocall.rs/feather/sun.svg> <img alt="Dark mode" id=moon-icon src=https://engineering.videocall.rs/feather/moon.svg></button></nav></header><script>function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.classList.contains('dark') ? 'dark' : 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    html.classList.remove(currentTheme);
    html.classList.add(newTheme);
    
    localStorage.setItem('theme', newTheme);
    updateThemeToggleIcons();
}

function updateThemeToggleIcons() {
    const sunIcon = document.getElementById('sun-icon');
    const moonIcon = document.getElementById('moon-icon');
    const isDarkMode = document.documentElement.classList.contains('dark');
    
    sunIcon.style.display = isDarkMode ? 'none' : 'inline';
    moonIcon.style.display = isDarkMode ? 'inline' : 'none';
}

// Set initial theme
const savedTheme = localStorage.getItem('theme') || 'light';
document.documentElement.classList.add(savedTheme);
updateThemeToggleIcons();</script><main><article><div class=title><div class=page-header>You'll Finally Understand Lifetimes in Rust After Read This<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-03-29</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://engineering.videocall.rs/posts/lifetimes/#what-are-lifetimes-and-why-do-we-need-them> What Are Lifetimes and Why Do We Need Them? </a><li><a href=https://engineering.videocall.rs/posts/lifetimes/#a-broken-example-when-lifetimes-are-missing> A Broken Example: When Lifetimes Are Missing </a><li><a href=https://engineering.videocall.rs/posts/lifetimes/#when-do-you-need-lifetimes> When Do You Need Lifetimes? </a><li><a href=https://engineering.videocall.rs/posts/lifetimes/#the-lifetime-elision-rules> The Lifetime Elision Rules </a></ul><section class=body><p>Lifetimes in Rust are often one of the most confusing topics for beginners. In fact, learning about lifetimes is actually same as learning why Rust is forcing you to write them. I'll try to keep this post as very simple and short, so if you are already familiar with Rust and lifetimes, this post definitely not for you.<h4 id=what-are-lifetimes-and-why-do-we-need-them><span style=color:orange> What Are Lifetimes and Why Do We Need Them? </span></h4><p>Lifetimes help the Rust compiler understand how long references (borrowed data) are valid. Imagine you have two pieces of paper borrowed from friends. You need to know how long you can safely use each piece before one of your friends asks for it back. Without knowing this, you might accidentally rely on a note that’s no longer available. That’s what lifetimes prevent in your code—they ensure references never outlive the data they point to.<h4 id=a-broken-example-when-lifetimes-are-missing><span style=color:orange> A Broken Example: When Lifetimes Are Missing </span></h4><p>Consider this function:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#5c6773;font-style:italic>// This function doesn't compile because Rust doesn't know how long the returned reference should be valid.
</span><span style=color:#f73>fn </span><span style=color:#ffb454>longest</span><span>(</span><span style=color:#f29718>x</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>str</span><span>, </span><span style=color:#f29718>y</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>str</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span style=color:#f73>str </span><span>{
</span><span>    </span><span style=color:#f73>if</span><span> x</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>() </span><span style=color:#f29668>></span><span> y</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>() {
</span><span>        x
</span><span>    } </span><span style=color:#f73>else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>main</span><span>() {
</span><span>    </span><span style=color:#f73>let</span><span> string1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#f29668>::</span><span>from(</span><span style=color:#c2d94c>"Hello"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> string2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#f29668>::</span><span>from(</span><span style=color:#c2d94c>"World"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> result </span><span style=color:#f29668>= </span><span style=color:#f07178>longest</span><span>(</span><span style=color:#f29668>&</span><span>string1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>string2)</span><span style=color:#bfbab0cc>; </span><span style=color:#5c6773;font-style:italic>// Compiler error: missing lifetime annotations
</span><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"The longest string is </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> result)</span><span style=color:#bfbab0cc>;
</span><span>}
</span></code></pre><p>Output:<pre style=color:#bfbab0;background-color:#0f1419><code><span>error[E0106]: missing lifetime specifier
</span><span> --> src/main.rs:1:33
</span><span>  |
</span><span>1 | fn longest(x: &str, y: &str) -> &str {
</span><span>  |               ----     ----     ^ expected named lifetime parameter
</span><span>  |
</span><span>  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</span></code></pre><p>Now, What’s the problem? The compiler is confused. It doesn’t know whether the returned reference is tied to <code>string1</code> or <code>string2</code>, or how long that <span style=color:orange>reference</span> should remain valid. Without this information, Rust can’t guarantee that the <span style=color:orange>reference</span> won’t point to data that no longer exists.<pre style=color:#bfbab0;background-color:#0f1419><code><span>// The Compiler's View
</span><span>                                                  
</span><span>&string1 ──┐                 
</span><span>           ├─▶ longest() ──▶ returns &str from... where?
</span><span>&string2 ──┘                 
</span><span>
</span><span>// Rust can't tell if the returned reference will outlive its source!
</span></code></pre><p>Now let's simply fix this by adding lifetimes:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>fn </span><span style=color:#ffb454>longest</span><span><</span><span style=color:#f73>'a</span><span>>(</span><span style=color:#f29718>x</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>'a str</span><span>, </span><span style=color:#f29718>y</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span style=color:#f73>'a str</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f29668>&</span><span style=color:#f73>'a str </span><span>{
</span><span>    </span><span style=color:#f73>if</span><span> x</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>() </span><span style=color:#f29668>></span><span> y</span><span style=color:#f29668>.</span><span style=color:#f07178>len</span><span>() {
</span><span>        x
</span><span>    } </span><span style=color:#f73>else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#f73>fn </span><span style=color:#ffb454>main</span><span>() {
</span><span>    </span><span style=color:#f73>let</span><span> string1 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#f29668>::</span><span>from(</span><span style=color:#c2d94c>"Hello"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> string2 </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#f29668>::</span><span>from(</span><span style=color:#c2d94c>"World"</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> result </span><span style=color:#f29668>= </span><span style=color:#f07178>longest</span><span>(</span><span style=color:#f29668>&</span><span>string1</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668>&</span><span>string2)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"The longest string is </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> result)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"We can still use string1: </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> string1)</span><span style=color:#bfbab0cc>; </span><span style=color:#5c6773;font-style:italic>// Still valid! thanks to lifetimes!!
</span><span>}
</span></code></pre><pre style=color:#bfbab0;background-color:#0f1419><code><span>
</span><span>&string1 ('a) ──┐                 
</span><span>                ├─▶ longest<'a>() ──▶ returns &'a str 
</span><span>&string2 ('a) ──┘                 
</span><span>
</span><span>// Now Rust knows the returned reference lives as long as both inputs!
</span></code></pre><ul><li>We added a lifetime parameter <code>'a</code> to the function signature.<li>We used this lifetime parameter to specify that the returned reference will live as long as the references passed in as arguments.<li>Now, the compiler knows how long the returned reference should be valid, and the code compiles successfully.</ul><h4 id=when-do-you-need-lifetimes><span style=color:orange> When Do You Need Lifetimes? </span></h4><p>I think this is the most important question to understand lifetimes. Generally, lifetimes are only necessary when you work with references. If you write a function that takes ownership of values, like a simple subtraction or sum, lifetimes aren’t needed. For example:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>fn </span><span style=color:#ffb454>sum</span><span>(</span><span style=color:#f29718>x</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>i32</span><span>, </span><span style=color:#f29718>y</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>i32</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#f73>i32 </span><span>{
</span><span>    x </span><span style=color:#f29668>+</span><span> y
</span><span>}
</span><span style=color:#f73>fn </span><span style=color:#ffb454>main </span><span>() {
</span><span>    </span><span style=color:#f73>let</span><span> x </span><span style=color:#f29668>= </span><span style=color:#f29718>5</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> y </span><span style=color:#f29668>= </span><span style=color:#f29718>10</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> result </span><span style=color:#f29668>= </span><span style=color:#f07178>sum</span><span>(x</span><span style=color:#bfbab0cc>,</span><span> y)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"The sum is </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> result)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"We can still use x: </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> x)</span><span style=color:#bfbab0cc>; 
</span><span>}
</span><span>
</span></code></pre><p>Here, no lifetimes are required because:<ul><li>No references (<code>&x</code> or <code>&y</code>): The function simple takes ownership of <code>x</code> and <code>y</code>.<li>Returns a new value: The result <code>x + y</code> is a brand-new <code>i32</code>, not a <span style=color:orange>reference</span>.<li>Nothing borrowed: Rust doesn't need to track how long <code>x</code> or <code>y</code> live because the values are already copied.</ul><p><span style=color:orange> Extra note: </span> You might ask why this still works:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span>    </span><span style=color:#f07178>println!</span><span>(</span><span style=color:#c2d94c>"We can still use x: </span><span style=color:#f29718>{}</span><span style=color:#c2d94c>"</span><span style=color:#bfbab0cc>,</span><span> x)</span><span style=color:#bfbab0cc>; 
</span></code></pre><p>The reason <code>x</code> is still usable after calling <code>sum</code> is that integers are "<code>Copy</code>" types in Rust. When you pass them to a function, they get copied, not moved. This is because integers are small, simple values that are cheap to duplicate.<h4 id=the-lifetime-elision-rules><span style=color:orange> The Lifetime Elision Rules </span></h4><p>Good thing is when you program in Rust in real-world projects, you don't need to write lifetimes all the time. Rust has smart defaults that often let you skip writing lifetimes explicitly. These are called "lifetime elision rules." You can read more about them in the <a href=https://doc.rust-lang.org/nomicon/lifetime-elision.html>official Rust book</a>.<p>But still, since I think that understanding the concept of lifetimes is an important cornerstone in understanding the overall paradigm of the Rust programming language, if I were to start Rust again, I would refer to and experiment with lifetimes even where I don't need to.</section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=https://engineering.videocall.rs/tags/rust/>rust</a><li><a href=https://engineering.videocall.rs/tags/lifetimes/>lifetimes</a></ul></nav></div></article></main><div class=giscus></div><script async crossorigin data-category=General data-category-id=DIC_kwDOL5Nyoc4CfU7n data-emit-metadata=0 data-input-position=bottom data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=altunenes/altunenes.github.io data-repo-id=R_kgDOL5NyoQ data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div>