// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod videocall {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod protocol {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum NetEqOperationCountersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NetEqOperationCounters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NetEqOperationCounters<'a> {
  type Inner = NetEqOperationCounters<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NetEqOperationCounters<'a> {
  pub const VT_NORMAL_PER_SEC: flatbuffers::VOffsetT = 4;
  pub const VT_EXPAND_PER_SEC: flatbuffers::VOffsetT = 6;
  pub const VT_ACCELERATE_PER_SEC: flatbuffers::VOffsetT = 8;
  pub const VT_FAST_ACCELERATE_PER_SEC: flatbuffers::VOffsetT = 10;
  pub const VT_PREEMPTIVE_EXPAND_PER_SEC: flatbuffers::VOffsetT = 12;
  pub const VT_MERGE_PER_SEC: flatbuffers::VOffsetT = 14;
  pub const VT_COMFORT_NOISE_PER_SEC: flatbuffers::VOffsetT = 16;
  pub const VT_DTMF_PER_SEC: flatbuffers::VOffsetT = 18;
  pub const VT_UNDEFINED_PER_SEC: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NetEqOperationCounters { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NetEqOperationCountersArgs
  ) -> flatbuffers::WIPOffset<NetEqOperationCounters<'bldr>> {
    let mut builder = NetEqOperationCountersBuilder::new(_fbb);
    builder.add_undefined_per_sec(args.undefined_per_sec);
    builder.add_dtmf_per_sec(args.dtmf_per_sec);
    builder.add_comfort_noise_per_sec(args.comfort_noise_per_sec);
    builder.add_merge_per_sec(args.merge_per_sec);
    builder.add_preemptive_expand_per_sec(args.preemptive_expand_per_sec);
    builder.add_fast_accelerate_per_sec(args.fast_accelerate_per_sec);
    builder.add_accelerate_per_sec(args.accelerate_per_sec);
    builder.add_expand_per_sec(args.expand_per_sec);
    builder.add_normal_per_sec(args.normal_per_sec);
    builder.finish()
  }

  pub fn unpack(&self) -> NetEqOperationCountersT {
    let normal_per_sec = self.normal_per_sec();
    let expand_per_sec = self.expand_per_sec();
    let accelerate_per_sec = self.accelerate_per_sec();
    let fast_accelerate_per_sec = self.fast_accelerate_per_sec();
    let preemptive_expand_per_sec = self.preemptive_expand_per_sec();
    let merge_per_sec = self.merge_per_sec();
    let comfort_noise_per_sec = self.comfort_noise_per_sec();
    let dtmf_per_sec = self.dtmf_per_sec();
    let undefined_per_sec = self.undefined_per_sec();
    NetEqOperationCountersT {
      normal_per_sec,
      expand_per_sec,
      accelerate_per_sec,
      fast_accelerate_per_sec,
      preemptive_expand_per_sec,
      merge_per_sec,
      comfort_noise_per_sec,
      dtmf_per_sec,
      undefined_per_sec,
    }
  }

  #[inline]
  pub fn normal_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_NORMAL_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn expand_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_EXPAND_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn accelerate_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_ACCELERATE_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn fast_accelerate_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_FAST_ACCELERATE_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn preemptive_expand_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_PREEMPTIVE_EXPAND_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn merge_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_MERGE_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn comfort_noise_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_COMFORT_NOISE_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn dtmf_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_DTMF_PER_SEC, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn undefined_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqOperationCounters::VT_UNDEFINED_PER_SEC, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for NetEqOperationCounters<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("normal_per_sec", Self::VT_NORMAL_PER_SEC, false)?
     .visit_field::<f64>("expand_per_sec", Self::VT_EXPAND_PER_SEC, false)?
     .visit_field::<f64>("accelerate_per_sec", Self::VT_ACCELERATE_PER_SEC, false)?
     .visit_field::<f64>("fast_accelerate_per_sec", Self::VT_FAST_ACCELERATE_PER_SEC, false)?
     .visit_field::<f64>("preemptive_expand_per_sec", Self::VT_PREEMPTIVE_EXPAND_PER_SEC, false)?
     .visit_field::<f64>("merge_per_sec", Self::VT_MERGE_PER_SEC, false)?
     .visit_field::<f64>("comfort_noise_per_sec", Self::VT_COMFORT_NOISE_PER_SEC, false)?
     .visit_field::<f64>("dtmf_per_sec", Self::VT_DTMF_PER_SEC, false)?
     .visit_field::<f64>("undefined_per_sec", Self::VT_UNDEFINED_PER_SEC, false)?
     .finish();
    Ok(())
  }
}
pub struct NetEqOperationCountersArgs {
    pub normal_per_sec: f64,
    pub expand_per_sec: f64,
    pub accelerate_per_sec: f64,
    pub fast_accelerate_per_sec: f64,
    pub preemptive_expand_per_sec: f64,
    pub merge_per_sec: f64,
    pub comfort_noise_per_sec: f64,
    pub dtmf_per_sec: f64,
    pub undefined_per_sec: f64,
}
impl<'a> Default for NetEqOperationCountersArgs {
  #[inline]
  fn default() -> Self {
    NetEqOperationCountersArgs {
      normal_per_sec: 0.0,
      expand_per_sec: 0.0,
      accelerate_per_sec: 0.0,
      fast_accelerate_per_sec: 0.0,
      preemptive_expand_per_sec: 0.0,
      merge_per_sec: 0.0,
      comfort_noise_per_sec: 0.0,
      dtmf_per_sec: 0.0,
      undefined_per_sec: 0.0,
    }
  }
}

pub struct NetEqOperationCountersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NetEqOperationCountersBuilder<'a, 'b> {
  #[inline]
  pub fn add_normal_per_sec(&mut self, normal_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_NORMAL_PER_SEC, normal_per_sec, 0.0);
  }
  #[inline]
  pub fn add_expand_per_sec(&mut self, expand_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_EXPAND_PER_SEC, expand_per_sec, 0.0);
  }
  #[inline]
  pub fn add_accelerate_per_sec(&mut self, accelerate_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_ACCELERATE_PER_SEC, accelerate_per_sec, 0.0);
  }
  #[inline]
  pub fn add_fast_accelerate_per_sec(&mut self, fast_accelerate_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_FAST_ACCELERATE_PER_SEC, fast_accelerate_per_sec, 0.0);
  }
  #[inline]
  pub fn add_preemptive_expand_per_sec(&mut self, preemptive_expand_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_PREEMPTIVE_EXPAND_PER_SEC, preemptive_expand_per_sec, 0.0);
  }
  #[inline]
  pub fn add_merge_per_sec(&mut self, merge_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_MERGE_PER_SEC, merge_per_sec, 0.0);
  }
  #[inline]
  pub fn add_comfort_noise_per_sec(&mut self, comfort_noise_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_COMFORT_NOISE_PER_SEC, comfort_noise_per_sec, 0.0);
  }
  #[inline]
  pub fn add_dtmf_per_sec(&mut self, dtmf_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_DTMF_PER_SEC, dtmf_per_sec, 0.0);
  }
  #[inline]
  pub fn add_undefined_per_sec(&mut self, undefined_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqOperationCounters::VT_UNDEFINED_PER_SEC, undefined_per_sec, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NetEqOperationCountersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NetEqOperationCountersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NetEqOperationCounters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NetEqOperationCounters<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NetEqOperationCounters");
      ds.field("normal_per_sec", &self.normal_per_sec());
      ds.field("expand_per_sec", &self.expand_per_sec());
      ds.field("accelerate_per_sec", &self.accelerate_per_sec());
      ds.field("fast_accelerate_per_sec", &self.fast_accelerate_per_sec());
      ds.field("preemptive_expand_per_sec", &self.preemptive_expand_per_sec());
      ds.field("merge_per_sec", &self.merge_per_sec());
      ds.field("comfort_noise_per_sec", &self.comfort_noise_per_sec());
      ds.field("dtmf_per_sec", &self.dtmf_per_sec());
      ds.field("undefined_per_sec", &self.undefined_per_sec());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NetEqOperationCountersT {
  pub normal_per_sec: f64,
  pub expand_per_sec: f64,
  pub accelerate_per_sec: f64,
  pub fast_accelerate_per_sec: f64,
  pub preemptive_expand_per_sec: f64,
  pub merge_per_sec: f64,
  pub comfort_noise_per_sec: f64,
  pub dtmf_per_sec: f64,
  pub undefined_per_sec: f64,
}
impl Default for NetEqOperationCountersT {
  fn default() -> Self {
    Self {
      normal_per_sec: 0.0,
      expand_per_sec: 0.0,
      accelerate_per_sec: 0.0,
      fast_accelerate_per_sec: 0.0,
      preemptive_expand_per_sec: 0.0,
      merge_per_sec: 0.0,
      comfort_noise_per_sec: 0.0,
      dtmf_per_sec: 0.0,
      undefined_per_sec: 0.0,
    }
  }
}
impl NetEqOperationCountersT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NetEqOperationCounters<'b>> {
    let normal_per_sec = self.normal_per_sec;
    let expand_per_sec = self.expand_per_sec;
    let accelerate_per_sec = self.accelerate_per_sec;
    let fast_accelerate_per_sec = self.fast_accelerate_per_sec;
    let preemptive_expand_per_sec = self.preemptive_expand_per_sec;
    let merge_per_sec = self.merge_per_sec;
    let comfort_noise_per_sec = self.comfort_noise_per_sec;
    let dtmf_per_sec = self.dtmf_per_sec;
    let undefined_per_sec = self.undefined_per_sec;
    NetEqOperationCounters::create(_fbb, &NetEqOperationCountersArgs{
      normal_per_sec,
      expand_per_sec,
      accelerate_per_sec,
      fast_accelerate_per_sec,
      preemptive_expand_per_sec,
      merge_per_sec,
      comfort_noise_per_sec,
      dtmf_per_sec,
      undefined_per_sec,
    })
  }
}
pub enum NetEqNetworkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NetEqNetwork<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NetEqNetwork<'a> {
  type Inner = NetEqNetwork<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NetEqNetwork<'a> {
  pub const VT_OPERATION_COUNTERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NetEqNetwork { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NetEqNetworkArgs<'args>
  ) -> flatbuffers::WIPOffset<NetEqNetwork<'bldr>> {
    let mut builder = NetEqNetworkBuilder::new(_fbb);
    if let Some(x) = args.operation_counters { builder.add_operation_counters(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> NetEqNetworkT {
    let operation_counters = self.operation_counters().map(|x| {
      Box::new(x.unpack())
    });
    NetEqNetworkT {
      operation_counters,
    }
  }

  #[inline]
  pub fn operation_counters(&self) -> Option<NetEqOperationCounters<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<NetEqOperationCounters>>(NetEqNetwork::VT_OPERATION_COUNTERS, None)
  }
}

impl flatbuffers::Verifiable for NetEqNetwork<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<NetEqOperationCounters>>("operation_counters", Self::VT_OPERATION_COUNTERS, false)?
     .finish();
    Ok(())
  }
}
pub struct NetEqNetworkArgs<'a> {
    pub operation_counters: Option<flatbuffers::WIPOffset<NetEqOperationCounters<'a>>>,
}
impl<'a> Default for NetEqNetworkArgs<'a> {
  #[inline]
  fn default() -> Self {
    NetEqNetworkArgs {
      operation_counters: None,
    }
  }
}

pub struct NetEqNetworkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NetEqNetworkBuilder<'a, 'b> {
  #[inline]
  pub fn add_operation_counters(&mut self, operation_counters: flatbuffers::WIPOffset<NetEqOperationCounters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NetEqOperationCounters>>(NetEqNetwork::VT_OPERATION_COUNTERS, operation_counters);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NetEqNetworkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NetEqNetworkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NetEqNetwork<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NetEqNetwork<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NetEqNetwork");
      ds.field("operation_counters", &self.operation_counters());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NetEqNetworkT {
  pub operation_counters: Option<Box<NetEqOperationCountersT>>,
}
impl Default for NetEqNetworkT {
  fn default() -> Self {
    Self {
      operation_counters: None,
    }
  }
}
impl NetEqNetworkT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NetEqNetwork<'b>> {
    let operation_counters = self.operation_counters.as_ref().map(|x|{
      x.pack(_fbb)
    });
    NetEqNetwork::create(_fbb, &NetEqNetworkArgs{
      operation_counters,
    })
  }
}
pub enum NetEqStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NetEqStats<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NetEqStats<'a> {
  type Inner = NetEqStats<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NetEqStats<'a> {
  pub const VT_CURRENT_BUFFER_SIZE_MS: flatbuffers::VOffsetT = 4;
  pub const VT_PACKETS_AWAITING_DECODE: flatbuffers::VOffsetT = 6;
  pub const VT_NETWORK: flatbuffers::VOffsetT = 8;
  pub const VT_PACKETS_PER_SEC: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NetEqStats { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NetEqStatsArgs<'args>
  ) -> flatbuffers::WIPOffset<NetEqStats<'bldr>> {
    let mut builder = NetEqStatsBuilder::new(_fbb);
    builder.add_packets_per_sec(args.packets_per_sec);
    builder.add_packets_awaiting_decode(args.packets_awaiting_decode);
    builder.add_current_buffer_size_ms(args.current_buffer_size_ms);
    if let Some(x) = args.network { builder.add_network(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> NetEqStatsT {
    let current_buffer_size_ms = self.current_buffer_size_ms();
    let packets_awaiting_decode = self.packets_awaiting_decode();
    let network = self.network().map(|x| {
      Box::new(x.unpack())
    });
    let packets_per_sec = self.packets_per_sec();
    NetEqStatsT {
      current_buffer_size_ms,
      packets_awaiting_decode,
      network,
      packets_per_sec,
    }
  }

  #[inline]
  pub fn current_buffer_size_ms(&self) -> f64 {
    self._tab.get::<f64>(NetEqStats::VT_CURRENT_BUFFER_SIZE_MS, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn packets_awaiting_decode(&self) -> f64 {
    self._tab.get::<f64>(NetEqStats::VT_PACKETS_AWAITING_DECODE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn network(&self) -> Option<NetEqNetwork<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<NetEqNetwork>>(NetEqStats::VT_NETWORK, None)
  }
  #[inline]
  pub fn packets_per_sec(&self) -> f64 {
    self._tab.get::<f64>(NetEqStats::VT_PACKETS_PER_SEC, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for NetEqStats<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("current_buffer_size_ms", Self::VT_CURRENT_BUFFER_SIZE_MS, false)?
     .visit_field::<f64>("packets_awaiting_decode", Self::VT_PACKETS_AWAITING_DECODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NetEqNetwork>>("network", Self::VT_NETWORK, false)?
     .visit_field::<f64>("packets_per_sec", Self::VT_PACKETS_PER_SEC, false)?
     .finish();
    Ok(())
  }
}
pub struct NetEqStatsArgs<'a> {
    pub current_buffer_size_ms: f64,
    pub packets_awaiting_decode: f64,
    pub network: Option<flatbuffers::WIPOffset<NetEqNetwork<'a>>>,
    pub packets_per_sec: f64,
}
impl<'a> Default for NetEqStatsArgs<'a> {
  #[inline]
  fn default() -> Self {
    NetEqStatsArgs {
      current_buffer_size_ms: 0.0,
      packets_awaiting_decode: 0.0,
      network: None,
      packets_per_sec: 0.0,
    }
  }
}

pub struct NetEqStatsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NetEqStatsBuilder<'a, 'b> {
  #[inline]
  pub fn add_current_buffer_size_ms(&mut self, current_buffer_size_ms: f64) {
    self.fbb_.push_slot::<f64>(NetEqStats::VT_CURRENT_BUFFER_SIZE_MS, current_buffer_size_ms, 0.0);
  }
  #[inline]
  pub fn add_packets_awaiting_decode(&mut self, packets_awaiting_decode: f64) {
    self.fbb_.push_slot::<f64>(NetEqStats::VT_PACKETS_AWAITING_DECODE, packets_awaiting_decode, 0.0);
  }
  #[inline]
  pub fn add_network(&mut self, network: flatbuffers::WIPOffset<NetEqNetwork<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NetEqNetwork>>(NetEqStats::VT_NETWORK, network);
  }
  #[inline]
  pub fn add_packets_per_sec(&mut self, packets_per_sec: f64) {
    self.fbb_.push_slot::<f64>(NetEqStats::VT_PACKETS_PER_SEC, packets_per_sec, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NetEqStatsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NetEqStatsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NetEqStats<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NetEqStats<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NetEqStats");
      ds.field("current_buffer_size_ms", &self.current_buffer_size_ms());
      ds.field("packets_awaiting_decode", &self.packets_awaiting_decode());
      ds.field("network", &self.network());
      ds.field("packets_per_sec", &self.packets_per_sec());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NetEqStatsT {
  pub current_buffer_size_ms: f64,
  pub packets_awaiting_decode: f64,
  pub network: Option<Box<NetEqNetworkT>>,
  pub packets_per_sec: f64,
}
impl Default for NetEqStatsT {
  fn default() -> Self {
    Self {
      current_buffer_size_ms: 0.0,
      packets_awaiting_decode: 0.0,
      network: None,
      packets_per_sec: 0.0,
    }
  }
}
impl NetEqStatsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NetEqStats<'b>> {
    let current_buffer_size_ms = self.current_buffer_size_ms;
    let packets_awaiting_decode = self.packets_awaiting_decode;
    let network = self.network.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let packets_per_sec = self.packets_per_sec;
    NetEqStats::create(_fbb, &NetEqStatsArgs{
      current_buffer_size_ms,
      packets_awaiting_decode,
      network,
      packets_per_sec,
    })
  }
}
pub enum VideoStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VideoStats<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VideoStats<'a> {
  type Inner = VideoStats<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> VideoStats<'a> {
  pub const VT_FPS_RECEIVED: flatbuffers::VOffsetT = 4;
  pub const VT_FRAMES_BUFFERED: flatbuffers::VOffsetT = 6;
  pub const VT_FRAMES_DECODED: flatbuffers::VOffsetT = 8;
  pub const VT_BITRATE_KBPS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VideoStats { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VideoStatsArgs
  ) -> flatbuffers::WIPOffset<VideoStats<'bldr>> {
    let mut builder = VideoStatsBuilder::new(_fbb);
    builder.add_bitrate_kbps(args.bitrate_kbps);
    builder.add_frames_decoded(args.frames_decoded);
    builder.add_frames_buffered(args.frames_buffered);
    builder.add_fps_received(args.fps_received);
    builder.finish()
  }

  pub fn unpack(&self) -> VideoStatsT {
    let fps_received = self.fps_received();
    let frames_buffered = self.frames_buffered();
    let frames_decoded = self.frames_decoded();
    let bitrate_kbps = self.bitrate_kbps();
    VideoStatsT {
      fps_received,
      frames_buffered,
      frames_decoded,
      bitrate_kbps,
    }
  }

  #[inline]
  pub fn fps_received(&self) -> f64 {
    self._tab.get::<f64>(VideoStats::VT_FPS_RECEIVED, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn frames_buffered(&self) -> f64 {
    self._tab.get::<f64>(VideoStats::VT_FRAMES_BUFFERED, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn frames_decoded(&self) -> u64 {
    self._tab.get::<u64>(VideoStats::VT_FRAMES_DECODED, Some(0)).unwrap()
  }
  #[inline]
  pub fn bitrate_kbps(&self) -> u64 {
    self._tab.get::<u64>(VideoStats::VT_BITRATE_KBPS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for VideoStats<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("fps_received", Self::VT_FPS_RECEIVED, false)?
     .visit_field::<f64>("frames_buffered", Self::VT_FRAMES_BUFFERED, false)?
     .visit_field::<u64>("frames_decoded", Self::VT_FRAMES_DECODED, false)?
     .visit_field::<u64>("bitrate_kbps", Self::VT_BITRATE_KBPS, false)?
     .finish();
    Ok(())
  }
}
pub struct VideoStatsArgs {
    pub fps_received: f64,
    pub frames_buffered: f64,
    pub frames_decoded: u64,
    pub bitrate_kbps: u64,
}
impl<'a> Default for VideoStatsArgs {
  #[inline]
  fn default() -> Self {
    VideoStatsArgs {
      fps_received: 0.0,
      frames_buffered: 0.0,
      frames_decoded: 0,
      bitrate_kbps: 0,
    }
  }
}

pub struct VideoStatsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VideoStatsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fps_received(&mut self, fps_received: f64) {
    self.fbb_.push_slot::<f64>(VideoStats::VT_FPS_RECEIVED, fps_received, 0.0);
  }
  #[inline]
  pub fn add_frames_buffered(&mut self, frames_buffered: f64) {
    self.fbb_.push_slot::<f64>(VideoStats::VT_FRAMES_BUFFERED, frames_buffered, 0.0);
  }
  #[inline]
  pub fn add_frames_decoded(&mut self, frames_decoded: u64) {
    self.fbb_.push_slot::<u64>(VideoStats::VT_FRAMES_DECODED, frames_decoded, 0);
  }
  #[inline]
  pub fn add_bitrate_kbps(&mut self, bitrate_kbps: u64) {
    self.fbb_.push_slot::<u64>(VideoStats::VT_BITRATE_KBPS, bitrate_kbps, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VideoStatsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VideoStatsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VideoStats<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VideoStats<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VideoStats");
      ds.field("fps_received", &self.fps_received());
      ds.field("frames_buffered", &self.frames_buffered());
      ds.field("frames_decoded", &self.frames_decoded());
      ds.field("bitrate_kbps", &self.bitrate_kbps());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VideoStatsT {
  pub fps_received: f64,
  pub frames_buffered: f64,
  pub frames_decoded: u64,
  pub bitrate_kbps: u64,
}
impl Default for VideoStatsT {
  fn default() -> Self {
    Self {
      fps_received: 0.0,
      frames_buffered: 0.0,
      frames_decoded: 0,
      bitrate_kbps: 0,
    }
  }
}
impl VideoStatsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<VideoStats<'b>> {
    let fps_received = self.fps_received;
    let frames_buffered = self.frames_buffered;
    let frames_decoded = self.frames_decoded;
    let bitrate_kbps = self.bitrate_kbps;
    VideoStats::create(_fbb, &VideoStatsArgs{
      fps_received,
      frames_buffered,
      frames_decoded,
      bitrate_kbps,
    })
  }
}
pub enum PeerStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PeerStats<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PeerStats<'a> {
  type Inner = PeerStats<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PeerStats<'a> {
  pub const VT_CAN_LISTEN: flatbuffers::VOffsetT = 4;
  pub const VT_CAN_SEE: flatbuffers::VOffsetT = 6;
  pub const VT_AUDIO_ENABLED: flatbuffers::VOffsetT = 8;
  pub const VT_VIDEO_ENABLED: flatbuffers::VOffsetT = 10;
  pub const VT_NETEQ_STATS: flatbuffers::VOffsetT = 12;
  pub const VT_VIDEO_STATS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PeerStats { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PeerStatsArgs<'args>
  ) -> flatbuffers::WIPOffset<PeerStats<'bldr>> {
    let mut builder = PeerStatsBuilder::new(_fbb);
    if let Some(x) = args.video_stats { builder.add_video_stats(x); }
    if let Some(x) = args.neteq_stats { builder.add_neteq_stats(x); }
    builder.add_video_enabled(args.video_enabled);
    builder.add_audio_enabled(args.audio_enabled);
    builder.add_can_see(args.can_see);
    builder.add_can_listen(args.can_listen);
    builder.finish()
  }

  pub fn unpack(&self) -> PeerStatsT {
    let can_listen = self.can_listen();
    let can_see = self.can_see();
    let audio_enabled = self.audio_enabled();
    let video_enabled = self.video_enabled();
    let neteq_stats = self.neteq_stats().map(|x| {
      Box::new(x.unpack())
    });
    let video_stats = self.video_stats().map(|x| {
      Box::new(x.unpack())
    });
    PeerStatsT {
      can_listen,
      can_see,
      audio_enabled,
      video_enabled,
      neteq_stats,
      video_stats,
    }
  }

  #[inline]
  pub fn can_listen(&self) -> bool {
    self._tab.get::<bool>(PeerStats::VT_CAN_LISTEN, Some(false)).unwrap()
  }
  #[inline]
  pub fn can_see(&self) -> bool {
    self._tab.get::<bool>(PeerStats::VT_CAN_SEE, Some(false)).unwrap()
  }
  #[inline]
  pub fn audio_enabled(&self) -> bool {
    self._tab.get::<bool>(PeerStats::VT_AUDIO_ENABLED, Some(false)).unwrap()
  }
  #[inline]
  pub fn video_enabled(&self) -> bool {
    self._tab.get::<bool>(PeerStats::VT_VIDEO_ENABLED, Some(false)).unwrap()
  }
  #[inline]
  pub fn neteq_stats(&self) -> Option<NetEqStats<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<NetEqStats>>(PeerStats::VT_NETEQ_STATS, None)
  }
  #[inline]
  pub fn video_stats(&self) -> Option<VideoStats<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VideoStats>>(PeerStats::VT_VIDEO_STATS, None)
  }
}

impl flatbuffers::Verifiable for PeerStats<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("can_listen", Self::VT_CAN_LISTEN, false)?
     .visit_field::<bool>("can_see", Self::VT_CAN_SEE, false)?
     .visit_field::<bool>("audio_enabled", Self::VT_AUDIO_ENABLED, false)?
     .visit_field::<bool>("video_enabled", Self::VT_VIDEO_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NetEqStats>>("neteq_stats", Self::VT_NETEQ_STATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VideoStats>>("video_stats", Self::VT_VIDEO_STATS, false)?
     .finish();
    Ok(())
  }
}
pub struct PeerStatsArgs<'a> {
    pub can_listen: bool,
    pub can_see: bool,
    pub audio_enabled: bool,
    pub video_enabled: bool,
    pub neteq_stats: Option<flatbuffers::WIPOffset<NetEqStats<'a>>>,
    pub video_stats: Option<flatbuffers::WIPOffset<VideoStats<'a>>>,
}
impl<'a> Default for PeerStatsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PeerStatsArgs {
      can_listen: false,
      can_see: false,
      audio_enabled: false,
      video_enabled: false,
      neteq_stats: None,
      video_stats: None,
    }
  }
}

pub struct PeerStatsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PeerStatsBuilder<'a, 'b> {
  #[inline]
  pub fn add_can_listen(&mut self, can_listen: bool) {
    self.fbb_.push_slot::<bool>(PeerStats::VT_CAN_LISTEN, can_listen, false);
  }
  #[inline]
  pub fn add_can_see(&mut self, can_see: bool) {
    self.fbb_.push_slot::<bool>(PeerStats::VT_CAN_SEE, can_see, false);
  }
  #[inline]
  pub fn add_audio_enabled(&mut self, audio_enabled: bool) {
    self.fbb_.push_slot::<bool>(PeerStats::VT_AUDIO_ENABLED, audio_enabled, false);
  }
  #[inline]
  pub fn add_video_enabled(&mut self, video_enabled: bool) {
    self.fbb_.push_slot::<bool>(PeerStats::VT_VIDEO_ENABLED, video_enabled, false);
  }
  #[inline]
  pub fn add_neteq_stats(&mut self, neteq_stats: flatbuffers::WIPOffset<NetEqStats<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NetEqStats>>(PeerStats::VT_NETEQ_STATS, neteq_stats);
  }
  #[inline]
  pub fn add_video_stats(&mut self, video_stats: flatbuffers::WIPOffset<VideoStats<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VideoStats>>(PeerStats::VT_VIDEO_STATS, video_stats);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PeerStatsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PeerStatsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PeerStats<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PeerStats<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PeerStats");
      ds.field("can_listen", &self.can_listen());
      ds.field("can_see", &self.can_see());
      ds.field("audio_enabled", &self.audio_enabled());
      ds.field("video_enabled", &self.video_enabled());
      ds.field("neteq_stats", &self.neteq_stats());
      ds.field("video_stats", &self.video_stats());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PeerStatsT {
  pub can_listen: bool,
  pub can_see: bool,
  pub audio_enabled: bool,
  pub video_enabled: bool,
  pub neteq_stats: Option<Box<NetEqStatsT>>,
  pub video_stats: Option<Box<VideoStatsT>>,
}
impl Default for PeerStatsT {
  fn default() -> Self {
    Self {
      can_listen: false,
      can_see: false,
      audio_enabled: false,
      video_enabled: false,
      neteq_stats: None,
      video_stats: None,
    }
  }
}
impl PeerStatsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PeerStats<'b>> {
    let can_listen = self.can_listen;
    let can_see = self.can_see;
    let audio_enabled = self.audio_enabled;
    let video_enabled = self.video_enabled;
    let neteq_stats = self.neteq_stats.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let video_stats = self.video_stats.as_ref().map(|x|{
      x.pack(_fbb)
    });
    PeerStats::create(_fbb, &PeerStatsArgs{
      can_listen,
      can_see,
      audio_enabled,
      video_enabled,
      neteq_stats,
      video_stats,
    })
  }
}
pub enum PeerStatsEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PeerStatsEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PeerStatsEntry<'a> {
  type Inner = PeerStatsEntry<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PeerStatsEntry<'a> {
  pub const VT_PEER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PeerStatsEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PeerStatsEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<PeerStatsEntry<'bldr>> {
    let mut builder = PeerStatsEntryBuilder::new(_fbb);
    if let Some(x) = args.stats { builder.add_stats(x); }
    if let Some(x) = args.peer_id { builder.add_peer_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PeerStatsEntryT {
    let peer_id = self.peer_id().map(|x| {
      x.to_string()
    });
    let stats = self.stats().map(|x| {
      Box::new(x.unpack())
    });
    PeerStatsEntryT {
      peer_id,
      stats,
    }
  }

  #[inline]
  pub fn peer_id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PeerStatsEntry::VT_PEER_ID, None)
  }
  #[inline]
  pub fn stats(&self) -> Option<PeerStats<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PeerStats>>(PeerStatsEntry::VT_STATS, None)
  }
}

impl flatbuffers::Verifiable for PeerStatsEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("peer_id", Self::VT_PEER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PeerStats>>("stats", Self::VT_STATS, false)?
     .finish();
    Ok(())
  }
}
pub struct PeerStatsEntryArgs<'a> {
    pub peer_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stats: Option<flatbuffers::WIPOffset<PeerStats<'a>>>,
}
impl<'a> Default for PeerStatsEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    PeerStatsEntryArgs {
      peer_id: None,
      stats: None,
    }
  }
}

pub struct PeerStatsEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PeerStatsEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_peer_id(&mut self, peer_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PeerStatsEntry::VT_PEER_ID, peer_id);
  }
  #[inline]
  pub fn add_stats(&mut self, stats: flatbuffers::WIPOffset<PeerStats<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PeerStats>>(PeerStatsEntry::VT_STATS, stats);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PeerStatsEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PeerStatsEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PeerStatsEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PeerStatsEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PeerStatsEntry");
      ds.field("peer_id", &self.peer_id());
      ds.field("stats", &self.stats());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PeerStatsEntryT {
  pub peer_id: Option<String>,
  pub stats: Option<Box<PeerStatsT>>,
}
impl Default for PeerStatsEntryT {
  fn default() -> Self {
    Self {
      peer_id: None,
      stats: None,
    }
  }
}
impl PeerStatsEntryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PeerStatsEntry<'b>> {
    let peer_id = self.peer_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let stats = self.stats.as_ref().map(|x|{
      x.pack(_fbb)
    });
    PeerStatsEntry::create(_fbb, &PeerStatsEntryArgs{
      peer_id,
      stats,
    })
  }
}
pub enum HealthPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HealthPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HealthPacket<'a> {
  type Inner = HealthPacket<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> HealthPacket<'a> {
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MEETING_ID: flatbuffers::VOffsetT = 6;
  pub const VT_REPORTING_PEER: flatbuffers::VOffsetT = 8;
  pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 10;
  pub const VT_REPORTING_AUDIO_ENABLED: flatbuffers::VOffsetT = 12;
  pub const VT_REPORTING_VIDEO_ENABLED: flatbuffers::VOffsetT = 14;
  pub const VT_PEER_STATS: flatbuffers::VOffsetT = 16;
  pub const VT_ACTIVE_SERVER_URL: flatbuffers::VOffsetT = 18;
  pub const VT_ACTIVE_SERVER_TYPE: flatbuffers::VOffsetT = 20;
  pub const VT_ACTIVE_SERVER_RTT_MS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HealthPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HealthPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<HealthPacket<'bldr>> {
    let mut builder = HealthPacketBuilder::new(_fbb);
    builder.add_active_server_rtt_ms(args.active_server_rtt_ms);
    builder.add_timestamp_ms(args.timestamp_ms);
    if let Some(x) = args.active_server_type { builder.add_active_server_type(x); }
    if let Some(x) = args.active_server_url { builder.add_active_server_url(x); }
    if let Some(x) = args.peer_stats { builder.add_peer_stats(x); }
    if let Some(x) = args.reporting_peer { builder.add_reporting_peer(x); }
    if let Some(x) = args.meeting_id { builder.add_meeting_id(x); }
    if let Some(x) = args.session_id { builder.add_session_id(x); }
    builder.add_reporting_video_enabled(args.reporting_video_enabled);
    builder.add_reporting_audio_enabled(args.reporting_audio_enabled);
    builder.finish()
  }

  pub fn unpack(&self) -> HealthPacketT {
    let session_id = self.session_id().map(|x| {
      x.to_string()
    });
    let meeting_id = self.meeting_id().map(|x| {
      x.to_string()
    });
    let reporting_peer = self.reporting_peer().map(|x| {
      x.to_string()
    });
    let timestamp_ms = self.timestamp_ms();
    let reporting_audio_enabled = self.reporting_audio_enabled();
    let reporting_video_enabled = self.reporting_video_enabled();
    let peer_stats = self.peer_stats().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let active_server_url = self.active_server_url().map(|x| {
      x.to_string()
    });
    let active_server_type = self.active_server_type().map(|x| {
      x.to_string()
    });
    let active_server_rtt_ms = self.active_server_rtt_ms();
    HealthPacketT {
      session_id,
      meeting_id,
      reporting_peer,
      timestamp_ms,
      reporting_audio_enabled,
      reporting_video_enabled,
      peer_stats,
      active_server_url,
      active_server_type,
      active_server_rtt_ms,
    }
  }

  #[inline]
  pub fn session_id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HealthPacket::VT_SESSION_ID, None)
  }
  #[inline]
  pub fn meeting_id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HealthPacket::VT_MEETING_ID, None)
  }
  #[inline]
  pub fn reporting_peer(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HealthPacket::VT_REPORTING_PEER, None)
  }
  #[inline]
  pub fn timestamp_ms(&self) -> u64 {
    self._tab.get::<u64>(HealthPacket::VT_TIMESTAMP_MS, Some(0)).unwrap()
  }
  #[inline]
  pub fn reporting_audio_enabled(&self) -> bool {
    self._tab.get::<bool>(HealthPacket::VT_REPORTING_AUDIO_ENABLED, Some(false)).unwrap()
  }
  #[inline]
  pub fn reporting_video_enabled(&self) -> bool {
    self._tab.get::<bool>(HealthPacket::VT_REPORTING_VIDEO_ENABLED, Some(false)).unwrap()
  }
  #[inline]
  pub fn peer_stats(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PeerStatsEntry<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PeerStatsEntry>>>>(HealthPacket::VT_PEER_STATS, None)
  }
  #[inline]
  pub fn active_server_url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HealthPacket::VT_ACTIVE_SERVER_URL, None)
  }
  #[inline]
  pub fn active_server_type(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HealthPacket::VT_ACTIVE_SERVER_TYPE, None)
  }
  #[inline]
  pub fn active_server_rtt_ms(&self) -> f64 {
    self._tab.get::<f64>(HealthPacket::VT_ACTIVE_SERVER_RTT_MS, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for HealthPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("meeting_id", Self::VT_MEETING_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reporting_peer", Self::VT_REPORTING_PEER, false)?
     .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
     .visit_field::<bool>("reporting_audio_enabled", Self::VT_REPORTING_AUDIO_ENABLED, false)?
     .visit_field::<bool>("reporting_video_enabled", Self::VT_REPORTING_VIDEO_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PeerStatsEntry>>>>("peer_stats", Self::VT_PEER_STATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("active_server_url", Self::VT_ACTIVE_SERVER_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("active_server_type", Self::VT_ACTIVE_SERVER_TYPE, false)?
     .visit_field::<f64>("active_server_rtt_ms", Self::VT_ACTIVE_SERVER_RTT_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct HealthPacketArgs<'a> {
    pub session_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub meeting_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reporting_peer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_ms: u64,
    pub reporting_audio_enabled: bool,
    pub reporting_video_enabled: bool,
    pub peer_stats: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PeerStatsEntry<'a>>>>>,
    pub active_server_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub active_server_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub active_server_rtt_ms: f64,
}
impl<'a> Default for HealthPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    HealthPacketArgs {
      session_id: None,
      meeting_id: None,
      reporting_peer: None,
      timestamp_ms: 0,
      reporting_audio_enabled: false,
      reporting_video_enabled: false,
      peer_stats: None,
      active_server_url: None,
      active_server_type: None,
      active_server_rtt_ms: 0.0,
    }
  }
}

pub struct HealthPacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HealthPacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_session_id(&mut self, session_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_SESSION_ID, session_id);
  }
  #[inline]
  pub fn add_meeting_id(&mut self, meeting_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_MEETING_ID, meeting_id);
  }
  #[inline]
  pub fn add_reporting_peer(&mut self, reporting_peer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_REPORTING_PEER, reporting_peer);
  }
  #[inline]
  pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
    self.fbb_.push_slot::<u64>(HealthPacket::VT_TIMESTAMP_MS, timestamp_ms, 0);
  }
  #[inline]
  pub fn add_reporting_audio_enabled(&mut self, reporting_audio_enabled: bool) {
    self.fbb_.push_slot::<bool>(HealthPacket::VT_REPORTING_AUDIO_ENABLED, reporting_audio_enabled, false);
  }
  #[inline]
  pub fn add_reporting_video_enabled(&mut self, reporting_video_enabled: bool) {
    self.fbb_.push_slot::<bool>(HealthPacket::VT_REPORTING_VIDEO_ENABLED, reporting_video_enabled, false);
  }
  #[inline]
  pub fn add_peer_stats(&mut self, peer_stats: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PeerStatsEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_PEER_STATS, peer_stats);
  }
  #[inline]
  pub fn add_active_server_url(&mut self, active_server_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_ACTIVE_SERVER_URL, active_server_url);
  }
  #[inline]
  pub fn add_active_server_type(&mut self, active_server_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HealthPacket::VT_ACTIVE_SERVER_TYPE, active_server_type);
  }
  #[inline]
  pub fn add_active_server_rtt_ms(&mut self, active_server_rtt_ms: f64) {
    self.fbb_.push_slot::<f64>(HealthPacket::VT_ACTIVE_SERVER_RTT_MS, active_server_rtt_ms, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HealthPacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HealthPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HealthPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HealthPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HealthPacket");
      ds.field("session_id", &self.session_id());
      ds.field("meeting_id", &self.meeting_id());
      ds.field("reporting_peer", &self.reporting_peer());
      ds.field("timestamp_ms", &self.timestamp_ms());
      ds.field("reporting_audio_enabled", &self.reporting_audio_enabled());
      ds.field("reporting_video_enabled", &self.reporting_video_enabled());
      ds.field("peer_stats", &self.peer_stats());
      ds.field("active_server_url", &self.active_server_url());
      ds.field("active_server_type", &self.active_server_type());
      ds.field("active_server_rtt_ms", &self.active_server_rtt_ms());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HealthPacketT {
  pub session_id: Option<String>,
  pub meeting_id: Option<String>,
  pub reporting_peer: Option<String>,
  pub timestamp_ms: u64,
  pub reporting_audio_enabled: bool,
  pub reporting_video_enabled: bool,
  pub peer_stats: Option<Vec<PeerStatsEntryT>>,
  pub active_server_url: Option<String>,
  pub active_server_type: Option<String>,
  pub active_server_rtt_ms: f64,
}
impl Default for HealthPacketT {
  fn default() -> Self {
    Self {
      session_id: None,
      meeting_id: None,
      reporting_peer: None,
      timestamp_ms: 0,
      reporting_audio_enabled: false,
      reporting_video_enabled: false,
      peer_stats: None,
      active_server_url: None,
      active_server_type: None,
      active_server_rtt_ms: 0.0,
    }
  }
}
impl HealthPacketT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<HealthPacket<'b>> {
    let session_id = self.session_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let meeting_id = self.meeting_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let reporting_peer = self.reporting_peer.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let timestamp_ms = self.timestamp_ms;
    let reporting_audio_enabled = self.reporting_audio_enabled;
    let reporting_video_enabled = self.reporting_video_enabled;
    let peer_stats = self.peer_stats.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let active_server_url = self.active_server_url.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let active_server_type = self.active_server_type.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let active_server_rtt_ms = self.active_server_rtt_ms;
    HealthPacket::create(_fbb, &HealthPacketArgs{
      session_id,
      meeting_id,
      reporting_peer,
      timestamp_ms,
      reporting_audio_enabled,
      reporting_video_enabled,
      peer_stats,
      active_server_url,
      active_server_type,
      active_server_rtt_ms,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_health_packet<'a>(buf: &'a [u8]) -> HealthPacket<'a> {
  unsafe { flatbuffers::root_unchecked::<HealthPacket<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_health_packet<'a>(buf: &'a [u8]) -> HealthPacket<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<HealthPacket<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `HealthPacket`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_health_packet_unchecked`.
pub fn root_as_health_packet(buf: &[u8]) -> Result<HealthPacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<HealthPacket>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `HealthPacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_health_packet_unchecked`.
pub fn size_prefixed_root_as_health_packet(buf: &[u8]) -> Result<HealthPacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<HealthPacket>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `HealthPacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_health_packet_unchecked`.
pub fn root_as_health_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HealthPacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<HealthPacket<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `HealthPacket` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_health_packet_unchecked`.
pub fn size_prefixed_root_as_health_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HealthPacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<HealthPacket<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a HealthPacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `HealthPacket`.
pub unsafe fn root_as_health_packet_unchecked(buf: &[u8]) -> HealthPacket {
  flatbuffers::root_unchecked::<HealthPacket>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed HealthPacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `HealthPacket`.
pub unsafe fn size_prefixed_root_as_health_packet_unchecked(buf: &[u8]) -> HealthPacket {
  flatbuffers::size_prefixed_root_unchecked::<HealthPacket>(buf)
}
#[inline]
pub fn finish_health_packet_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HealthPacket<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_health_packet_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<HealthPacket<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod protocol
}  // pub mod videocall

