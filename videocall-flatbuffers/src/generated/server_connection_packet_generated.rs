// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod videocall {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod protocol {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EVENT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EVENT_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TYPE: [EventType; 4] = [
  EventType::UNKNOWN,
  EventType::CONNECTION_STARTED,
  EventType::CONNECTION_ENDED,
  EventType::DATA_TRANSFERRED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventType(pub i8);
#[allow(non_upper_case_globals)]
impl EventType {
  pub const UNKNOWN: Self = Self(0);
  pub const CONNECTION_STARTED: Self = Self(1);
  pub const CONNECTION_ENDED: Self = Self(2);
  pub const DATA_TRANSFERRED: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::CONNECTION_STARTED,
    Self::CONNECTION_ENDED,
    Self::DATA_TRANSFERRED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::CONNECTION_STARTED => Some("CONNECTION_STARTED"),
      Self::CONNECTION_ENDED => Some("CONNECTION_ENDED"),
      Self::DATA_TRANSFERRED => Some("DATA_TRANSFERRED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EventType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EventType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for EventType {
    type Output = EventType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for EventType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EventType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EventType {}
pub enum DataTransferInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DataTransferInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataTransferInfo<'a> {
  type Inner = DataTransferInfo<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DataTransferInfo<'a> {
  pub const VT_BYTES_SENT: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES_RECEIVED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DataTransferInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DataTransferInfoArgs
  ) -> flatbuffers::WIPOffset<DataTransferInfo<'bldr>> {
    let mut builder = DataTransferInfoBuilder::new(_fbb);
    builder.add_bytes_received(args.bytes_received);
    builder.add_bytes_sent(args.bytes_sent);
    builder.finish()
  }

  pub fn unpack(&self) -> DataTransferInfoT {
    let bytes_sent = self.bytes_sent();
    let bytes_received = self.bytes_received();
    DataTransferInfoT {
      bytes_sent,
      bytes_received,
    }
  }

  #[inline]
  pub fn bytes_sent(&self) -> u64 {
    self._tab.get::<u64>(DataTransferInfo::VT_BYTES_SENT, Some(0)).unwrap()
  }
  #[inline]
  pub fn bytes_received(&self) -> u64 {
    self._tab.get::<u64>(DataTransferInfo::VT_BYTES_RECEIVED, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for DataTransferInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("bytes_sent", Self::VT_BYTES_SENT, false)?
     .visit_field::<u64>("bytes_received", Self::VT_BYTES_RECEIVED, false)?
     .finish();
    Ok(())
  }
}
pub struct DataTransferInfoArgs {
    pub bytes_sent: u64,
    pub bytes_received: u64,
}
impl<'a> Default for DataTransferInfoArgs {
  #[inline]
  fn default() -> Self {
    DataTransferInfoArgs {
      bytes_sent: 0,
      bytes_received: 0,
    }
  }
}

pub struct DataTransferInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataTransferInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_bytes_sent(&mut self, bytes_sent: u64) {
    self.fbb_.push_slot::<u64>(DataTransferInfo::VT_BYTES_SENT, bytes_sent, 0);
  }
  #[inline]
  pub fn add_bytes_received(&mut self, bytes_received: u64) {
    self.fbb_.push_slot::<u64>(DataTransferInfo::VT_BYTES_RECEIVED, bytes_received, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataTransferInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataTransferInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataTransferInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DataTransferInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DataTransferInfo");
      ds.field("bytes_sent", &self.bytes_sent());
      ds.field("bytes_received", &self.bytes_received());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DataTransferInfoT {
  pub bytes_sent: u64,
  pub bytes_received: u64,
}
impl Default for DataTransferInfoT {
  fn default() -> Self {
    Self {
      bytes_sent: 0,
      bytes_received: 0,
    }
  }
}
impl DataTransferInfoT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DataTransferInfo<'b>> {
    let bytes_sent = self.bytes_sent;
    let bytes_received = self.bytes_received;
    DataTransferInfo::create(_fbb, &DataTransferInfoArgs{
      bytes_sent,
      bytes_received,
    })
  }
}
pub enum ConnectionMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConnectionMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectionMetadata<'a> {
  type Inner = ConnectionMetadata<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConnectionMetadata<'a> {
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CUSTOMER_EMAIL: flatbuffers::VOffsetT = 6;
  pub const VT_MEETING_ID: flatbuffers::VOffsetT = 8;
  pub const VT_PROTOCOL: flatbuffers::VOffsetT = 10;
  pub const VT_SERVER_INSTANCE: flatbuffers::VOffsetT = 12;
  pub const VT_REGION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConnectionMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConnectionMetadataArgs<'args>
  ) -> flatbuffers::WIPOffset<ConnectionMetadata<'bldr>> {
    let mut builder = ConnectionMetadataBuilder::new(_fbb);
    if let Some(x) = args.region { builder.add_region(x); }
    if let Some(x) = args.server_instance { builder.add_server_instance(x); }
    if let Some(x) = args.protocol { builder.add_protocol(x); }
    if let Some(x) = args.meeting_id { builder.add_meeting_id(x); }
    if let Some(x) = args.customer_email { builder.add_customer_email(x); }
    if let Some(x) = args.session_id { builder.add_session_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ConnectionMetadataT {
    let session_id = self.session_id().map(|x| {
      x.to_string()
    });
    let customer_email = self.customer_email().map(|x| {
      x.to_string()
    });
    let meeting_id = self.meeting_id().map(|x| {
      x.to_string()
    });
    let protocol = self.protocol().map(|x| {
      x.to_string()
    });
    let server_instance = self.server_instance().map(|x| {
      x.to_string()
    });
    let region = self.region().map(|x| {
      x.to_string()
    });
    ConnectionMetadataT {
      session_id,
      customer_email,
      meeting_id,
      protocol,
      server_instance,
      region,
    }
  }

  #[inline]
  pub fn session_id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_SESSION_ID, None)
  }
  #[inline]
  pub fn customer_email(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_CUSTOMER_EMAIL, None)
  }
  #[inline]
  pub fn meeting_id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_MEETING_ID, None)
  }
  #[inline]
  pub fn protocol(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_PROTOCOL, None)
  }
  #[inline]
  pub fn server_instance(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_SERVER_INSTANCE, None)
  }
  #[inline]
  pub fn region(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionMetadata::VT_REGION, None)
  }
}

impl flatbuffers::Verifiable for ConnectionMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("customer_email", Self::VT_CUSTOMER_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("meeting_id", Self::VT_MEETING_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("protocol", Self::VT_PROTOCOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("server_instance", Self::VT_SERVER_INSTANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("region", Self::VT_REGION, false)?
     .finish();
    Ok(())
  }
}
pub struct ConnectionMetadataArgs<'a> {
    pub session_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub customer_email: Option<flatbuffers::WIPOffset<&'a str>>,
    pub meeting_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub protocol: Option<flatbuffers::WIPOffset<&'a str>>,
    pub server_instance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub region: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConnectionMetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConnectionMetadataArgs {
      session_id: None,
      customer_email: None,
      meeting_id: None,
      protocol: None,
      server_instance: None,
      region: None,
    }
  }
}

pub struct ConnectionMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectionMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_session_id(&mut self, session_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_SESSION_ID, session_id);
  }
  #[inline]
  pub fn add_customer_email(&mut self, customer_email: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_CUSTOMER_EMAIL, customer_email);
  }
  #[inline]
  pub fn add_meeting_id(&mut self, meeting_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_MEETING_ID, meeting_id);
  }
  #[inline]
  pub fn add_protocol(&mut self, protocol: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_PROTOCOL, protocol);
  }
  #[inline]
  pub fn add_server_instance(&mut self, server_instance: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_SERVER_INSTANCE, server_instance);
  }
  #[inline]
  pub fn add_region(&mut self, region: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionMetadata::VT_REGION, region);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectionMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectionMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectionMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConnectionMetadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConnectionMetadata");
      ds.field("session_id", &self.session_id());
      ds.field("customer_email", &self.customer_email());
      ds.field("meeting_id", &self.meeting_id());
      ds.field("protocol", &self.protocol());
      ds.field("server_instance", &self.server_instance());
      ds.field("region", &self.region());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConnectionMetadataT {
  pub session_id: Option<String>,
  pub customer_email: Option<String>,
  pub meeting_id: Option<String>,
  pub protocol: Option<String>,
  pub server_instance: Option<String>,
  pub region: Option<String>,
}
impl Default for ConnectionMetadataT {
  fn default() -> Self {
    Self {
      session_id: None,
      customer_email: None,
      meeting_id: None,
      protocol: None,
      server_instance: None,
      region: None,
    }
  }
}
impl ConnectionMetadataT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ConnectionMetadata<'b>> {
    let session_id = self.session_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let customer_email = self.customer_email.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let meeting_id = self.meeting_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let protocol = self.protocol.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let server_instance = self.server_instance.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let region = self.region.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ConnectionMetadata::create(_fbb, &ConnectionMetadataArgs{
      session_id,
      customer_email,
      meeting_id,
      protocol,
      server_instance,
      region,
    })
  }
}
pub enum ServerConnectionPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ServerConnectionPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ServerConnectionPacket<'a> {
  type Inner = ServerConnectionPacket<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ServerConnectionPacket<'a> {
  pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 6;
  pub const VT_CONNECTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_TRANSFER: flatbuffers::VOffsetT = 10;
  pub const VT_CONNECTION_DURATION_MS: flatbuffers::VOffsetT = 12;
  pub const VT_IS_RECONNECTION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ServerConnectionPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ServerConnectionPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<ServerConnectionPacket<'bldr>> {
    let mut builder = ServerConnectionPacketBuilder::new(_fbb);
    builder.add_connection_duration_ms(args.connection_duration_ms);
    builder.add_timestamp_ms(args.timestamp_ms);
    if let Some(x) = args.data_transfer { builder.add_data_transfer(x); }
    if let Some(x) = args.connection { builder.add_connection(x); }
    builder.add_is_reconnection(args.is_reconnection);
    builder.add_event_type(args.event_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ServerConnectionPacketT {
    let event_type = self.event_type();
    let timestamp_ms = self.timestamp_ms();
    let connection = self.connection().map(|x| {
      Box::new(x.unpack())
    });
    let data_transfer = self.data_transfer().map(|x| {
      Box::new(x.unpack())
    });
    let connection_duration_ms = self.connection_duration_ms();
    let is_reconnection = self.is_reconnection();
    ServerConnectionPacketT {
      event_type,
      timestamp_ms,
      connection,
      data_transfer,
      connection_duration_ms,
      is_reconnection,
    }
  }

  #[inline]
  pub fn event_type(&self) -> EventType {
    self._tab.get::<EventType>(ServerConnectionPacket::VT_EVENT_TYPE, Some(EventType::UNKNOWN)).unwrap()
  }
  #[inline]
  pub fn timestamp_ms(&self) -> u64 {
    self._tab.get::<u64>(ServerConnectionPacket::VT_TIMESTAMP_MS, Some(0)).unwrap()
  }
  #[inline]
  pub fn connection(&self) -> Option<ConnectionMetadata<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ConnectionMetadata>>(ServerConnectionPacket::VT_CONNECTION, None)
  }
  #[inline]
  pub fn data_transfer(&self) -> Option<DataTransferInfo<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DataTransferInfo>>(ServerConnectionPacket::VT_DATA_TRANSFER, None)
  }
  #[inline]
  pub fn connection_duration_ms(&self) -> u64 {
    self._tab.get::<u64>(ServerConnectionPacket::VT_CONNECTION_DURATION_MS, Some(0)).unwrap()
  }
  #[inline]
  pub fn is_reconnection(&self) -> bool {
    self._tab.get::<bool>(ServerConnectionPacket::VT_IS_RECONNECTION, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for ServerConnectionPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<EventType>("event_type", Self::VT_EVENT_TYPE, false)?
     .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ConnectionMetadata>>("connection", Self::VT_CONNECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DataTransferInfo>>("data_transfer", Self::VT_DATA_TRANSFER, false)?
     .visit_field::<u64>("connection_duration_ms", Self::VT_CONNECTION_DURATION_MS, false)?
     .visit_field::<bool>("is_reconnection", Self::VT_IS_RECONNECTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ServerConnectionPacketArgs<'a> {
    pub event_type: EventType,
    pub timestamp_ms: u64,
    pub connection: Option<flatbuffers::WIPOffset<ConnectionMetadata<'a>>>,
    pub data_transfer: Option<flatbuffers::WIPOffset<DataTransferInfo<'a>>>,
    pub connection_duration_ms: u64,
    pub is_reconnection: bool,
}
impl<'a> Default for ServerConnectionPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServerConnectionPacketArgs {
      event_type: EventType::UNKNOWN,
      timestamp_ms: 0,
      connection: None,
      data_transfer: None,
      connection_duration_ms: 0,
      is_reconnection: false,
    }
  }
}

pub struct ServerConnectionPacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ServerConnectionPacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_type(&mut self, event_type: EventType) {
    self.fbb_.push_slot::<EventType>(ServerConnectionPacket::VT_EVENT_TYPE, event_type, EventType::UNKNOWN);
  }
  #[inline]
  pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
    self.fbb_.push_slot::<u64>(ServerConnectionPacket::VT_TIMESTAMP_MS, timestamp_ms, 0);
  }
  #[inline]
  pub fn add_connection(&mut self, connection: flatbuffers::WIPOffset<ConnectionMetadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ConnectionMetadata>>(ServerConnectionPacket::VT_CONNECTION, connection);
  }
  #[inline]
  pub fn add_data_transfer(&mut self, data_transfer: flatbuffers::WIPOffset<DataTransferInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DataTransferInfo>>(ServerConnectionPacket::VT_DATA_TRANSFER, data_transfer);
  }
  #[inline]
  pub fn add_connection_duration_ms(&mut self, connection_duration_ms: u64) {
    self.fbb_.push_slot::<u64>(ServerConnectionPacket::VT_CONNECTION_DURATION_MS, connection_duration_ms, 0);
  }
  #[inline]
  pub fn add_is_reconnection(&mut self, is_reconnection: bool) {
    self.fbb_.push_slot::<bool>(ServerConnectionPacket::VT_IS_RECONNECTION, is_reconnection, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ServerConnectionPacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ServerConnectionPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ServerConnectionPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ServerConnectionPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ServerConnectionPacket");
      ds.field("event_type", &self.event_type());
      ds.field("timestamp_ms", &self.timestamp_ms());
      ds.field("connection", &self.connection());
      ds.field("data_transfer", &self.data_transfer());
      ds.field("connection_duration_ms", &self.connection_duration_ms());
      ds.field("is_reconnection", &self.is_reconnection());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ServerConnectionPacketT {
  pub event_type: EventType,
  pub timestamp_ms: u64,
  pub connection: Option<Box<ConnectionMetadataT>>,
  pub data_transfer: Option<Box<DataTransferInfoT>>,
  pub connection_duration_ms: u64,
  pub is_reconnection: bool,
}
impl Default for ServerConnectionPacketT {
  fn default() -> Self {
    Self {
      event_type: EventType::UNKNOWN,
      timestamp_ms: 0,
      connection: None,
      data_transfer: None,
      connection_duration_ms: 0,
      is_reconnection: false,
    }
  }
}
impl ServerConnectionPacketT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ServerConnectionPacket<'b>> {
    let event_type = self.event_type;
    let timestamp_ms = self.timestamp_ms;
    let connection = self.connection.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let data_transfer = self.data_transfer.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let connection_duration_ms = self.connection_duration_ms;
    let is_reconnection = self.is_reconnection;
    ServerConnectionPacket::create(_fbb, &ServerConnectionPacketArgs{
      event_type,
      timestamp_ms,
      connection,
      data_transfer,
      connection_duration_ms,
      is_reconnection,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_server_connection_packet<'a>(buf: &'a [u8]) -> ServerConnectionPacket<'a> {
  unsafe { flatbuffers::root_unchecked::<ServerConnectionPacket<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_server_connection_packet<'a>(buf: &'a [u8]) -> ServerConnectionPacket<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<ServerConnectionPacket<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `ServerConnectionPacket`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_server_connection_packet_unchecked`.
pub fn root_as_server_connection_packet(buf: &[u8]) -> Result<ServerConnectionPacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ServerConnectionPacket>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ServerConnectionPacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_server_connection_packet_unchecked`.
pub fn size_prefixed_root_as_server_connection_packet(buf: &[u8]) -> Result<ServerConnectionPacket, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ServerConnectionPacket>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ServerConnectionPacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_server_connection_packet_unchecked`.
pub fn root_as_server_connection_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ServerConnectionPacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ServerConnectionPacket<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ServerConnectionPacket` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_server_connection_packet_unchecked`.
pub fn size_prefixed_root_as_server_connection_packet_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ServerConnectionPacket<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ServerConnectionPacket<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ServerConnectionPacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ServerConnectionPacket`.
pub unsafe fn root_as_server_connection_packet_unchecked(buf: &[u8]) -> ServerConnectionPacket {
  flatbuffers::root_unchecked::<ServerConnectionPacket>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ServerConnectionPacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ServerConnectionPacket`.
pub unsafe fn size_prefixed_root_as_server_connection_packet_unchecked(buf: &[u8]) -> ServerConnectionPacket {
  flatbuffers::size_prefixed_root_unchecked::<ServerConnectionPacket>(buf)
}
#[inline]
pub fn finish_server_connection_packet_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ServerConnectionPacket<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_server_connection_packet_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ServerConnectionPacket<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod protocol
}  // pub mod videocall

