// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `types/health_packet.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:health_packet.NetEqOperationCounters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetEqOperationCounters {
    // message fields
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.normal_per_sec)
    pub normal_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.expand_per_sec)
    pub expand_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.accelerate_per_sec)
    pub accelerate_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.fast_accelerate_per_sec)
    pub fast_accelerate_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.preemptive_expand_per_sec)
    pub preemptive_expand_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.merge_per_sec)
    pub merge_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.comfort_noise_per_sec)
    pub comfort_noise_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.dtmf_per_sec)
    pub dtmf_per_sec: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqOperationCounters.undefined_per_sec)
    pub undefined_per_sec: f64,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.NetEqOperationCounters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetEqOperationCounters {
    fn default() -> &'a NetEqOperationCounters {
        <NetEqOperationCounters as ::protobuf::Message>::default_instance()
    }
}

impl NetEqOperationCounters {
    pub fn new() -> NetEqOperationCounters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "normal_per_sec",
            |m: &NetEqOperationCounters| { &m.normal_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.normal_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expand_per_sec",
            |m: &NetEqOperationCounters| { &m.expand_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.expand_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accelerate_per_sec",
            |m: &NetEqOperationCounters| { &m.accelerate_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.accelerate_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fast_accelerate_per_sec",
            |m: &NetEqOperationCounters| { &m.fast_accelerate_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.fast_accelerate_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preemptive_expand_per_sec",
            |m: &NetEqOperationCounters| { &m.preemptive_expand_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.preemptive_expand_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merge_per_sec",
            |m: &NetEqOperationCounters| { &m.merge_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.merge_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comfort_noise_per_sec",
            |m: &NetEqOperationCounters| { &m.comfort_noise_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.comfort_noise_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dtmf_per_sec",
            |m: &NetEqOperationCounters| { &m.dtmf_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.dtmf_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "undefined_per_sec",
            |m: &NetEqOperationCounters| { &m.undefined_per_sec },
            |m: &mut NetEqOperationCounters| { &mut m.undefined_per_sec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetEqOperationCounters>(
            "NetEqOperationCounters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetEqOperationCounters {
    const NAME: &'static str = "NetEqOperationCounters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.normal_per_sec = is.read_double()?;
                },
                17 => {
                    self.expand_per_sec = is.read_double()?;
                },
                25 => {
                    self.accelerate_per_sec = is.read_double()?;
                },
                33 => {
                    self.fast_accelerate_per_sec = is.read_double()?;
                },
                41 => {
                    self.preemptive_expand_per_sec = is.read_double()?;
                },
                49 => {
                    self.merge_per_sec = is.read_double()?;
                },
                57 => {
                    self.comfort_noise_per_sec = is.read_double()?;
                },
                65 => {
                    self.dtmf_per_sec = is.read_double()?;
                },
                73 => {
                    self.undefined_per_sec = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.normal_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.expand_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.accelerate_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.fast_accelerate_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.preemptive_expand_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.merge_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.comfort_noise_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.dtmf_per_sec != 0. {
            my_size += 1 + 8;
        }
        if self.undefined_per_sec != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.normal_per_sec != 0. {
            os.write_double(1, self.normal_per_sec)?;
        }
        if self.expand_per_sec != 0. {
            os.write_double(2, self.expand_per_sec)?;
        }
        if self.accelerate_per_sec != 0. {
            os.write_double(3, self.accelerate_per_sec)?;
        }
        if self.fast_accelerate_per_sec != 0. {
            os.write_double(4, self.fast_accelerate_per_sec)?;
        }
        if self.preemptive_expand_per_sec != 0. {
            os.write_double(5, self.preemptive_expand_per_sec)?;
        }
        if self.merge_per_sec != 0. {
            os.write_double(6, self.merge_per_sec)?;
        }
        if self.comfort_noise_per_sec != 0. {
            os.write_double(7, self.comfort_noise_per_sec)?;
        }
        if self.dtmf_per_sec != 0. {
            os.write_double(8, self.dtmf_per_sec)?;
        }
        if self.undefined_per_sec != 0. {
            os.write_double(9, self.undefined_per_sec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetEqOperationCounters {
        NetEqOperationCounters::new()
    }

    fn clear(&mut self) {
        self.normal_per_sec = 0.;
        self.expand_per_sec = 0.;
        self.accelerate_per_sec = 0.;
        self.fast_accelerate_per_sec = 0.;
        self.preemptive_expand_per_sec = 0.;
        self.merge_per_sec = 0.;
        self.comfort_noise_per_sec = 0.;
        self.dtmf_per_sec = 0.;
        self.undefined_per_sec = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetEqOperationCounters {
        static instance: NetEqOperationCounters = NetEqOperationCounters {
            normal_per_sec: 0.,
            expand_per_sec: 0.,
            accelerate_per_sec: 0.,
            fast_accelerate_per_sec: 0.,
            preemptive_expand_per_sec: 0.,
            merge_per_sec: 0.,
            comfort_noise_per_sec: 0.,
            dtmf_per_sec: 0.,
            undefined_per_sec: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetEqOperationCounters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetEqOperationCounters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetEqOperationCounters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetEqOperationCounters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:health_packet.NetEqNetwork)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetEqNetwork {
    // message fields
    // @@protoc_insertion_point(field:health_packet.NetEqNetwork.operation_counters)
    pub operation_counters: ::protobuf::MessageField<NetEqOperationCounters>,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.NetEqNetwork.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetEqNetwork {
    fn default() -> &'a NetEqNetwork {
        <NetEqNetwork as ::protobuf::Message>::default_instance()
    }
}

impl NetEqNetwork {
    pub fn new() -> NetEqNetwork {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetEqOperationCounters>(
            "operation_counters",
            |m: &NetEqNetwork| { &m.operation_counters },
            |m: &mut NetEqNetwork| { &mut m.operation_counters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetEqNetwork>(
            "NetEqNetwork",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetEqNetwork {
    const NAME: &'static str = "NetEqNetwork";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operation_counters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation_counters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation_counters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetEqNetwork {
        NetEqNetwork::new()
    }

    fn clear(&mut self) {
        self.operation_counters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetEqNetwork {
        static instance: NetEqNetwork = NetEqNetwork {
            operation_counters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetEqNetwork {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetEqNetwork").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetEqNetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetEqNetwork {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:health_packet.NetEqStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetEqStats {
    // message fields
    // @@protoc_insertion_point(field:health_packet.NetEqStats.current_buffer_size_ms)
    pub current_buffer_size_ms: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqStats.packets_awaiting_decode)
    pub packets_awaiting_decode: f64,
    // @@protoc_insertion_point(field:health_packet.NetEqStats.network)
    pub network: ::protobuf::MessageField<NetEqNetwork>,
    ///  Number of audio packets received per second (rolling 1s window)
    // @@protoc_insertion_point(field:health_packet.NetEqStats.packets_per_sec)
    pub packets_per_sec: f64,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.NetEqStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetEqStats {
    fn default() -> &'a NetEqStats {
        <NetEqStats as ::protobuf::Message>::default_instance()
    }
}

impl NetEqStats {
    pub fn new() -> NetEqStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_buffer_size_ms",
            |m: &NetEqStats| { &m.current_buffer_size_ms },
            |m: &mut NetEqStats| { &mut m.current_buffer_size_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "packets_awaiting_decode",
            |m: &NetEqStats| { &m.packets_awaiting_decode },
            |m: &mut NetEqStats| { &mut m.packets_awaiting_decode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetEqNetwork>(
            "network",
            |m: &NetEqStats| { &m.network },
            |m: &mut NetEqStats| { &mut m.network },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "packets_per_sec",
            |m: &NetEqStats| { &m.packets_per_sec },
            |m: &mut NetEqStats| { &mut m.packets_per_sec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetEqStats>(
            "NetEqStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetEqStats {
    const NAME: &'static str = "NetEqStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.current_buffer_size_ms = is.read_double()?;
                },
                17 => {
                    self.packets_awaiting_decode = is.read_double()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.network)?;
                },
                33 => {
                    self.packets_per_sec = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.current_buffer_size_ms != 0. {
            my_size += 1 + 8;
        }
        if self.packets_awaiting_decode != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.packets_per_sec != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.current_buffer_size_ms != 0. {
            os.write_double(1, self.current_buffer_size_ms)?;
        }
        if self.packets_awaiting_decode != 0. {
            os.write_double(2, self.packets_awaiting_decode)?;
        }
        if let Some(v) = self.network.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.packets_per_sec != 0. {
            os.write_double(4, self.packets_per_sec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetEqStats {
        NetEqStats::new()
    }

    fn clear(&mut self) {
        self.current_buffer_size_ms = 0.;
        self.packets_awaiting_decode = 0.;
        self.network.clear();
        self.packets_per_sec = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetEqStats {
        static instance: NetEqStats = NetEqStats {
            current_buffer_size_ms: 0.,
            packets_awaiting_decode: 0.,
            network: ::protobuf::MessageField::none(),
            packets_per_sec: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetEqStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetEqStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetEqStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetEqStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:health_packet.VideoStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoStats {
    // message fields
    // @@protoc_insertion_point(field:health_packet.VideoStats.fps_received)
    pub fps_received: f64,
    // @@protoc_insertion_point(field:health_packet.VideoStats.frames_buffered)
    pub frames_buffered: f64,
    // @@protoc_insertion_point(field:health_packet.VideoStats.frames_decoded)
    pub frames_decoded: u64,
    // @@protoc_insertion_point(field:health_packet.VideoStats.bitrate_kbps)
    pub bitrate_kbps: u64,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.VideoStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoStats {
    fn default() -> &'a VideoStats {
        <VideoStats as ::protobuf::Message>::default_instance()
    }
}

impl VideoStats {
    pub fn new() -> VideoStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fps_received",
            |m: &VideoStats| { &m.fps_received },
            |m: &mut VideoStats| { &mut m.fps_received },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frames_buffered",
            |m: &VideoStats| { &m.frames_buffered },
            |m: &mut VideoStats| { &mut m.frames_buffered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frames_decoded",
            |m: &VideoStats| { &m.frames_decoded },
            |m: &mut VideoStats| { &mut m.frames_decoded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bitrate_kbps",
            |m: &VideoStats| { &m.bitrate_kbps },
            |m: &mut VideoStats| { &mut m.bitrate_kbps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoStats>(
            "VideoStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoStats {
    const NAME: &'static str = "VideoStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.fps_received = is.read_double()?;
                },
                17 => {
                    self.frames_buffered = is.read_double()?;
                },
                24 => {
                    self.frames_decoded = is.read_uint64()?;
                },
                32 => {
                    self.bitrate_kbps = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fps_received != 0. {
            my_size += 1 + 8;
        }
        if self.frames_buffered != 0. {
            my_size += 1 + 8;
        }
        if self.frames_decoded != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.frames_decoded);
        }
        if self.bitrate_kbps != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.bitrate_kbps);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fps_received != 0. {
            os.write_double(1, self.fps_received)?;
        }
        if self.frames_buffered != 0. {
            os.write_double(2, self.frames_buffered)?;
        }
        if self.frames_decoded != 0 {
            os.write_uint64(3, self.frames_decoded)?;
        }
        if self.bitrate_kbps != 0 {
            os.write_uint64(4, self.bitrate_kbps)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoStats {
        VideoStats::new()
    }

    fn clear(&mut self) {
        self.fps_received = 0.;
        self.frames_buffered = 0.;
        self.frames_decoded = 0;
        self.bitrate_kbps = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoStats {
        static instance: VideoStats = VideoStats {
            fps_received: 0.,
            frames_buffered: 0.,
            frames_decoded: 0,
            bitrate_kbps: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:health_packet.PeerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeerStats {
    // message fields
    ///  Receiver-observed connectivity booleans
    // @@protoc_insertion_point(field:health_packet.PeerStats.can_listen)
    pub can_listen: bool,
    // @@protoc_insertion_point(field:health_packet.PeerStats.can_see)
    pub can_see: bool,
    ///  Receiver-observed sender state flags (from peer_status)
    // @@protoc_insertion_point(field:health_packet.PeerStats.audio_enabled)
    pub audio_enabled: bool,
    // @@protoc_insertion_point(field:health_packet.PeerStats.video_enabled)
    pub video_enabled: bool,
    ///  Structured stats
    // @@protoc_insertion_point(field:health_packet.PeerStats.neteq_stats)
    pub neteq_stats: ::protobuf::MessageField<NetEqStats>,
    // @@protoc_insertion_point(field:health_packet.PeerStats.video_stats)
    pub video_stats: ::protobuf::MessageField<VideoStats>,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.PeerStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerStats {
    fn default() -> &'a PeerStats {
        <PeerStats as ::protobuf::Message>::default_instance()
    }
}

impl PeerStats {
    pub fn new() -> PeerStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_listen",
            |m: &PeerStats| { &m.can_listen },
            |m: &mut PeerStats| { &mut m.can_listen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_see",
            |m: &PeerStats| { &m.can_see },
            |m: &mut PeerStats| { &mut m.can_see },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "audio_enabled",
            |m: &PeerStats| { &m.audio_enabled },
            |m: &mut PeerStats| { &mut m.audio_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video_enabled",
            |m: &PeerStats| { &m.video_enabled },
            |m: &mut PeerStats| { &mut m.video_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetEqStats>(
            "neteq_stats",
            |m: &PeerStats| { &m.neteq_stats },
            |m: &mut PeerStats| { &mut m.neteq_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VideoStats>(
            "video_stats",
            |m: &PeerStats| { &m.video_stats },
            |m: &mut PeerStats| { &mut m.video_stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerStats>(
            "PeerStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerStats {
    const NAME: &'static str = "PeerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_listen = is.read_bool()?;
                },
                16 => {
                    self.can_see = is.read_bool()?;
                },
                24 => {
                    self.audio_enabled = is.read_bool()?;
                },
                32 => {
                    self.video_enabled = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.neteq_stats)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.video_stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_listen != false {
            my_size += 1 + 1;
        }
        if self.can_see != false {
            my_size += 1 + 1;
        }
        if self.audio_enabled != false {
            my_size += 1 + 1;
        }
        if self.video_enabled != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.neteq_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.video_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_listen != false {
            os.write_bool(1, self.can_listen)?;
        }
        if self.can_see != false {
            os.write_bool(2, self.can_see)?;
        }
        if self.audio_enabled != false {
            os.write_bool(3, self.audio_enabled)?;
        }
        if self.video_enabled != false {
            os.write_bool(4, self.video_enabled)?;
        }
        if let Some(v) = self.neteq_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.video_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerStats {
        PeerStats::new()
    }

    fn clear(&mut self) {
        self.can_listen = false;
        self.can_see = false;
        self.audio_enabled = false;
        self.video_enabled = false;
        self.neteq_stats.clear();
        self.video_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerStats {
        static instance: PeerStats = PeerStats {
            can_listen: false,
            can_see: false,
            audio_enabled: false,
            video_enabled: false,
            neteq_stats: ::protobuf::MessageField::none(),
            video_stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:health_packet.HealthPacket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HealthPacket {
    // message fields
    // @@protoc_insertion_point(field:health_packet.HealthPacket.session_id)
    pub session_id: ::std::string::String,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.meeting_id)
    pub meeting_id: ::std::string::String,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.reporting_peer)
    pub reporting_peer: ::std::string::String,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.timestamp_ms)
    pub timestamp_ms: u64,
    ///  Sender self-reported state (authoritative)
    // @@protoc_insertion_point(field:health_packet.HealthPacket.reporting_audio_enabled)
    pub reporting_audio_enabled: bool,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.reporting_video_enabled)
    pub reporting_video_enabled: bool,
    ///  Per-peer stats keyed by peer_id (to_peer)
    // @@protoc_insertion_point(field:health_packet.HealthPacket.peer_stats)
    pub peer_stats: ::std::collections::HashMap<::std::string::String, PeerStats>,
    ///  Active connection info (client-side measured)
    // @@protoc_insertion_point(field:health_packet.HealthPacket.active_server_url)
    pub active_server_url: ::std::string::String,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.active_server_type)
    pub active_server_type: ::std::string::String,
    // @@protoc_insertion_point(field:health_packet.HealthPacket.active_server_rtt_ms)
    pub active_server_rtt_ms: f64,
    // special fields
    // @@protoc_insertion_point(special_field:health_packet.HealthPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HealthPacket {
    fn default() -> &'a HealthPacket {
        <HealthPacket as ::protobuf::Message>::default_instance()
    }
}

impl HealthPacket {
    pub fn new() -> HealthPacket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &HealthPacket| { &m.session_id },
            |m: &mut HealthPacket| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "meeting_id",
            |m: &HealthPacket| { &m.meeting_id },
            |m: &mut HealthPacket| { &mut m.meeting_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reporting_peer",
            |m: &HealthPacket| { &m.reporting_peer },
            |m: &mut HealthPacket| { &mut m.reporting_peer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp_ms",
            |m: &HealthPacket| { &m.timestamp_ms },
            |m: &mut HealthPacket| { &mut m.timestamp_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reporting_audio_enabled",
            |m: &HealthPacket| { &m.reporting_audio_enabled },
            |m: &mut HealthPacket| { &mut m.reporting_audio_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reporting_video_enabled",
            |m: &HealthPacket| { &m.reporting_video_enabled },
            |m: &mut HealthPacket| { &mut m.reporting_video_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "peer_stats",
            |m: &HealthPacket| { &m.peer_stats },
            |m: &mut HealthPacket| { &mut m.peer_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_server_url",
            |m: &HealthPacket| { &m.active_server_url },
            |m: &mut HealthPacket| { &mut m.active_server_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_server_type",
            |m: &HealthPacket| { &m.active_server_type },
            |m: &mut HealthPacket| { &mut m.active_server_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_server_rtt_ms",
            |m: &HealthPacket| { &m.active_server_rtt_ms },
            |m: &mut HealthPacket| { &mut m.active_server_rtt_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealthPacket>(
            "HealthPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HealthPacket {
    const NAME: &'static str = "HealthPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id = is.read_string()?;
                },
                18 => {
                    self.meeting_id = is.read_string()?;
                },
                26 => {
                    self.reporting_peer = is.read_string()?;
                },
                32 => {
                    self.timestamp_ms = is.read_uint64()?;
                },
                40 => {
                    self.reporting_audio_enabled = is.read_bool()?;
                },
                48 => {
                    self.reporting_video_enabled = is.read_bool()?;
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.peer_stats.insert(key, value);
                },
                66 => {
                    self.active_server_url = is.read_string()?;
                },
                74 => {
                    self.active_server_type = is.read_string()?;
                },
                81 => {
                    self.active_server_rtt_ms = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_id);
        }
        if !self.meeting_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.meeting_id);
        }
        if !self.reporting_peer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.reporting_peer);
        }
        if self.timestamp_ms != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.timestamp_ms);
        }
        if self.reporting_audio_enabled != false {
            my_size += 1 + 1;
        }
        if self.reporting_video_enabled != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.peer_stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.active_server_url.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.active_server_url);
        }
        if !self.active_server_type.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.active_server_type);
        }
        if self.active_server_rtt_ms != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session_id.is_empty() {
            os.write_string(1, &self.session_id)?;
        }
        if !self.meeting_id.is_empty() {
            os.write_string(2, &self.meeting_id)?;
        }
        if !self.reporting_peer.is_empty() {
            os.write_string(3, &self.reporting_peer)?;
        }
        if self.timestamp_ms != 0 {
            os.write_uint64(4, self.timestamp_ms)?;
        }
        if self.reporting_audio_enabled != false {
            os.write_bool(5, self.reporting_audio_enabled)?;
        }
        if self.reporting_video_enabled != false {
            os.write_bool(6, self.reporting_video_enabled)?;
        }
        for (k, v) in &self.peer_stats {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.active_server_url.is_empty() {
            os.write_string(8, &self.active_server_url)?;
        }
        if !self.active_server_type.is_empty() {
            os.write_string(9, &self.active_server_type)?;
        }
        if self.active_server_rtt_ms != 0. {
            os.write_double(10, self.active_server_rtt_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HealthPacket {
        HealthPacket::new()
    }

    fn clear(&mut self) {
        self.session_id.clear();
        self.meeting_id.clear();
        self.reporting_peer.clear();
        self.timestamp_ms = 0;
        self.reporting_audio_enabled = false;
        self.reporting_video_enabled = false;
        self.peer_stats.clear();
        self.active_server_url.clear();
        self.active_server_type.clear();
        self.active_server_rtt_ms = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HealthPacket {
        static instance: ::protobuf::rt::Lazy<HealthPacket> = ::protobuf::rt::Lazy::new();
        instance.get(HealthPacket::new)
    }
}

impl ::protobuf::MessageFull for HealthPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HealthPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HealthPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19types/health_packet.proto\x12\rhealth_packet\"\xa9\x03\n\x16NetEqO\
    perationCounters\x12$\n\x0enormal_per_sec\x18\x01\x20\x01(\x01R\x0cnorma\
    lPerSec\x12$\n\x0eexpand_per_sec\x18\x02\x20\x01(\x01R\x0cexpandPerSec\
    \x12,\n\x12accelerate_per_sec\x18\x03\x20\x01(\x01R\x10acceleratePerSec\
    \x125\n\x17fast_accelerate_per_sec\x18\x04\x20\x01(\x01R\x14fastAccelera\
    tePerSec\x129\n\x19preemptive_expand_per_sec\x18\x05\x20\x01(\x01R\x16pr\
    eemptiveExpandPerSec\x12\"\n\rmerge_per_sec\x18\x06\x20\x01(\x01R\x0bmer\
    gePerSec\x121\n\x15comfort_noise_per_sec\x18\x07\x20\x01(\x01R\x12comfor\
    tNoisePerSec\x12\x20\n\x0cdtmf_per_sec\x18\x08\x20\x01(\x01R\ndtmfPerSec\
    \x12*\n\x11undefined_per_sec\x18\t\x20\x01(\x01R\x0fundefinedPerSec\"d\n\
    \x0cNetEqNetwork\x12T\n\x12operation_counters\x18\x01\x20\x01(\x0b2%.hea\
    lth_packet.NetEqOperationCountersR\x11operationCounters\"\xd8\x01\n\nNet\
    EqStats\x123\n\x16current_buffer_size_ms\x18\x01\x20\x01(\x01R\x13curren\
    tBufferSizeMs\x126\n\x17packets_awaiting_decode\x18\x02\x20\x01(\x01R\
    \x15packetsAwaitingDecode\x125\n\x07network\x18\x03\x20\x01(\x0b2\x1b.he\
    alth_packet.NetEqNetworkR\x07network\x12&\n\x0fpackets_per_sec\x18\x04\
    \x20\x01(\x01R\rpacketsPerSec\"\xa2\x01\n\nVideoStats\x12!\n\x0cfps_rece\
    ived\x18\x01\x20\x01(\x01R\x0bfpsReceived\x12'\n\x0fframes_buffered\x18\
    \x02\x20\x01(\x01R\x0eframesBuffered\x12%\n\x0eframes_decoded\x18\x03\
    \x20\x01(\x04R\rframesDecoded\x12!\n\x0cbitrate_kbps\x18\x04\x20\x01(\
    \x04R\x0bbitrateKbps\"\x85\x02\n\tPeerStats\x12\x1d\n\ncan_listen\x18\
    \x01\x20\x01(\x08R\tcanListen\x12\x17\n\x07can_see\x18\x02\x20\x01(\x08R\
    \x06canSee\x12#\n\raudio_enabled\x18\x03\x20\x01(\x08R\x0caudioEnabled\
    \x12#\n\rvideo_enabled\x18\x04\x20\x01(\x08R\x0cvideoEnabled\x12:\n\x0bn\
    eteq_stats\x18\x05\x20\x01(\x0b2\x19.health_packet.NetEqStatsR\nneteqSta\
    ts\x12:\n\x0bvideo_stats\x18\x06\x20\x01(\x0b2\x19.health_packet.VideoSt\
    atsR\nvideoStats\"\xb4\x04\n\x0cHealthPacket\x12\x1d\n\nsession_id\x18\
    \x01\x20\x01(\tR\tsessionId\x12\x1d\n\nmeeting_id\x18\x02\x20\x01(\tR\tm\
    eetingId\x12%\n\x0ereporting_peer\x18\x03\x20\x01(\tR\rreportingPeer\x12\
    !\n\x0ctimestamp_ms\x18\x04\x20\x01(\x04R\x0btimestampMs\x126\n\x17repor\
    ting_audio_enabled\x18\x05\x20\x01(\x08R\x15reportingAudioEnabled\x126\n\
    \x17reporting_video_enabled\x18\x06\x20\x01(\x08R\x15reportingVideoEnabl\
    ed\x12I\n\npeer_stats\x18\x07\x20\x03(\x0b2*.health_packet.HealthPacket.\
    PeerStatsEntryR\tpeerStats\x12*\n\x11active_server_url\x18\x08\x20\x01(\
    \tR\x0factiveServerUrl\x12,\n\x12active_server_type\x18\t\x20\x01(\tR\
    \x10activeServerType\x12/\n\x14active_server_rtt_ms\x18\n\x20\x01(\x01R\
    \x11activeServerRttMs\x1aV\n\x0ePeerStatsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12.\n\x05value\x18\x02\x20\x01(\x0b2\x18.health_pac\
    ket.PeerStatsR\x05value:\x028\x01J\xc5\x13\n\x06\x12\x04\0\0B\x01\n\x08\
    \n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x16\n\n\n\x02\
    \x04\0\x12\x04\x04\0\x0e\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x1e\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x05\x02\x1c\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x05\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x05\t\x17\n\x0c\
    \n\x05\x04\0\x02\0\x03\x12\x03\x05\x1a\x1b\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x06\x02\x1c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x06\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03\x06\t\x17\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x06\x1a\x1b\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x07\x02\x20\n\x0c\
    \n\x05\x04\0\x02\x02\x05\x12\x03\x07\x02\x08\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03\x07\t\x1b\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x07\x1e\x1f\
    \n\x0b\n\x04\x04\0\x02\x03\x12\x03\x08\x02%\n\x0c\n\x05\x04\0\x02\x03\
    \x05\x12\x03\x08\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x08\t\x20\
    \n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x08#$\n\x0b\n\x04\x04\0\x02\x04\
    \x12\x03\t\x02'\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\t\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x04\x01\x12\x03\t\t\"\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03\t%&\n\x0b\n\x04\x04\0\x02\x05\x12\x03\n\x02\x1b\n\x0c\n\x05\x04\0\
    \x02\x05\x05\x12\x03\n\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\n\t\
    \x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\n\x19\x1a\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03\x0b\x02#\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x0b\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x0b\t\x1e\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03\x0b!\"\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x0c\x02\
    \x1a\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x0c\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x07\x01\x12\x03\x0c\t\x15\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x0c\
    \x18\x19\n\x0b\n\x04\x04\0\x02\x08\x12\x03\r\x02\x1f\n\x0c\n\x05\x04\0\
    \x02\x08\x05\x12\x03\r\x02\x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\r\t\
    \x1a\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\r\x1d\x1e\n\n\n\x02\x04\x01\
    \x12\x04\x10\0\x12\x01\n\n\n\x03\x04\x01\x01\x12\x03\x10\x08\x14\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03\x11\x020\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03\x11\x02\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x11\x19+\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03\x11./\n\n\n\x02\x04\x02\x12\x04\x14\0\x1a\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03\x14\x08\x12\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03\x15\x02$\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x15\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x15\t\x1f\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03\x15\"#\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x16\x02%\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03\x16\t\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x16#$\n\
    \x0b\n\x04\x04\x02\x02\x02\x12\x03\x17\x02\x1b\n\x0c\n\x05\x04\x02\x02\
    \x02\x06\x12\x03\x17\x02\x0e\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x17\
    \x0f\x16\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x17\x19\x1a\nN\n\x04\
    \x04\x02\x02\x03\x12\x03\x19\x02\x1d\x1aA\x20Number\x20of\x20audio\x20pa\
    ckets\x20received\x20per\x20second\x20(rolling\x201s\x20window)\n\n\x0c\
    \n\x05\x04\x02\x02\x03\x05\x12\x03\x19\x02\x08\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03\x19\t\x18\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x19\
    \x1b\x1c\n\n\n\x02\x04\x03\x12\x04\x1c\0!\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03\x1c\x08\x12\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1d\x02\x1a\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x03\x1d\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03\x1d\t\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x1d\x18\x19\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03\x1e\x02\x1d\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x1e\
    \t\x18\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1e\x1b\x1c\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03\x1f\x02\x1c\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03\x1f\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03\x1f\t\x17\n\x0c\
    \n\x05\x04\x03\x02\x02\x03\x12\x03\x1f\x1a\x1b\n\x0b\n\x04\x04\x03\x02\
    \x03\x12\x03\x20\x02\x1a\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03\x20\x02\
    \x08\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\x20\t\x15\n\x0c\n\x05\x04\
    \x03\x02\x03\x03\x12\x03\x20\x18\x19\n\n\n\x02\x04\x04\x12\x04#\0/\x01\n\
    \n\n\x03\x04\x04\x01\x12\x03#\x08\x11\n6\n\x04\x04\x04\x02\0\x12\x03%\
    \x02\x16\x1a)\x20Receiver-observed\x20connectivity\x20booleans\n\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03%\x02\x06\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03%\x07\x11\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03%\x14\x15\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03&\x02\x13\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03&\x02\x06\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03&\x07\x0e\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x03&\x11\x12\nw\n\x04\x04\x04\x02\x02\x12\
    \x03)\x02\x19\x1a9\x20Receiver-observed\x20sender\x20state\x20flags\x20(\
    from\x20peer_status)\n\"/\x20true\x20if\x20receiver\x20reports\x20sender\
    \x20audio\x20enabled\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03)\x02\x06\
    \n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03)\x07\x14\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03)\x17\x18\n<\n\x04\x04\x04\x02\x03\x12\x03*\x02\x19\
    \"/\x20true\x20if\x20receiver\x20reports\x20sender\x20video\x20enabled\n\
    \n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03*\x02\x06\n\x0c\n\x05\x04\x04\
    \x02\x03\x01\x12\x03*\x07\x14\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03*\
    \x17\x18\n\x1f\n\x04\x04\x04\x02\x04\x12\x03-\x02\x1d\x1a\x12\x20Structu\
    red\x20stats\n\n\x0c\n\x05\x04\x04\x02\x04\x06\x12\x03-\x02\x0c\n\x0c\n\
    \x05\x04\x04\x02\x04\x01\x12\x03-\r\x18\n\x0c\n\x05\x04\x04\x02\x04\x03\
    \x12\x03-\x1b\x1c\n\x0b\n\x04\x04\x04\x02\x05\x12\x03.\x02\x1d\n\x0c\n\
    \x05\x04\x04\x02\x05\x06\x12\x03.\x02\x0c\n\x0c\n\x05\x04\x04\x02\x05\
    \x01\x12\x03.\r\x18\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03.\x1b\x1c\n\n\
    \n\x02\x04\x05\x12\x041\0B\x01\n\n\n\x03\x04\x05\x01\x12\x031\x08\x14\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x032\x02\x18\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x032\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x032\t\x13\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x032\x16\x17\n\x0b\n\x04\x04\x05\x02\x01\x12\
    \x033\x02\x18\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x033\x02\x08\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x033\t\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\
    \x12\x033\x16\x17\n\x0b\n\x04\x04\x05\x02\x02\x12\x034\x02\x1c\n\x0c\n\
    \x05\x04\x05\x02\x02\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x034\t\x17\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x034\x1a\x1b\n\
    \x0b\n\x04\x04\x05\x02\x03\x12\x035\x02\x1a\n\x0c\n\x05\x04\x05\x02\x03\
    \x05\x12\x035\x02\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x035\t\x15\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x035\x18\x19\n9\n\x04\x04\x05\x02\x04\
    \x12\x038\x02#\x1a,\x20Sender\x20self-reported\x20state\x20(authoritativ\
    e)\n\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x038\x02\x06\n\x0c\n\x05\x04\
    \x05\x02\x04\x01\x12\x038\x07\x1e\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\
    \x038!\"\n\x0b\n\x04\x04\x05\x02\x05\x12\x039\x02#\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x039\x02\x06\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x039\
    \x07\x1e\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x039!\"\n8\n\x04\x04\x05\
    \x02\x06\x12\x03<\x02(\x1a+\x20Per-peer\x20stats\x20keyed\x20by\x20peer_\
    id\x20(to_peer)\n\n\x0c\n\x05\x04\x05\x02\x06\x06\x12\x03<\x02\x18\n\x0c\
    \n\x05\x04\x05\x02\x06\x01\x12\x03<\x19#\n\x0c\n\x05\x04\x05\x02\x06\x03\
    \x12\x03<&'\n<\n\x04\x04\x05\x02\x07\x12\x03?\x02\x1f\x1a/\x20Active\x20\
    connection\x20info\x20(client-side\x20measured)\n\n\x0c\n\x05\x04\x05\
    \x02\x07\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03?\t\
    \x1a\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03?\x1d\x1e\n+\n\x04\x04\x05\
    \x02\x08\x12\x03@\x02\x20\"\x1e\x20\"webtransport\"\x20|\x20\"websocket\
    \"\n\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03@\x02\x08\n\x0c\n\x05\x04\
    \x05\x02\x08\x01\x12\x03@\t\x1b\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03@\
    \x1e\x1f\n\x0b\n\x04\x04\x05\x02\t\x12\x03A\x02#\n\x0c\n\x05\x04\x05\x02\
    \t\x05\x12\x03A\x02\x08\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03A\t\x1d\n\
    \x0c\n\x05\x04\x05\x02\t\x03\x12\x03A\x20\"b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(NetEqOperationCounters::generated_message_descriptor_data());
            messages.push(NetEqNetwork::generated_message_descriptor_data());
            messages.push(NetEqStats::generated_message_descriptor_data());
            messages.push(VideoStats::generated_message_descriptor_data());
            messages.push(PeerStats::generated_message_descriptor_data());
            messages.push(HealthPacket::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
