// yew-ui/static/workers/ios_camera_worker.js

let wasm_encoder_module = null; // Will be initialized via message
let wasm_encoder_instance = null;

// Simple function to handle errors (replace with more robust logging/reporting)
function logError(error) {
    console.error("iOS Worker Error:", error);
    // Optionally: self.postMessage({ type: 'error', detail: error.toString() });
}

// Function to process an ImageBitmap
async function processFrame(imageBitmap) {
    if (!wasm_encoder_instance) {
        logError("WASM encoder not initialized in worker.");
        imageBitmap.close(); // Release bitmap resource
        return;
    }

    const width = imageBitmap.width;
    const height = imageBitmap.height;

    // 1. Draw to OffscreenCanvas to get pixel data
    // Use OffscreenCanvas for rendering off the main thread
    const offscreenCanvas = new OffscreenCanvas(width, height);
    const ctx = offscreenCanvas.getContext('2d', { alpha: false }); // No alpha needed usually
    if (!ctx) {
        logError("Could not get OffscreenCanvas 2D context.");
        imageBitmap.close();
        return;
    }
    ctx.drawImage(imageBitmap, 0, 0);
    imageBitmap.close(); // Release bitmap resource promptly

    // 2. Get Pixel Data (ImageData)
    // This is still a sync readback, but off the main thread.
    let imageData = null;
    try {
        imageData = ctx.getImageData(0, 0, width, height);
        if (!imageData || !imageData.data) {
           throw new Error("getImageData returned invalid data");
        }
    } catch (e) {
        logError(`getImageData failed: ${e}`);
        return;
    }

    // 3. Prepare data for WASM (e.g., get the underlying ArrayBuffer)
    // The WASM function will need to know width, height, and expect RGBA data format.
    // NOTE: This assumes wasm_encoder_instance.encode_frame expects the buffer directly.
    // You might need to copy it into WASM memory depending on your bindings.
    const frameDataBuffer = imageData.data.buffer;
    const timestamp = performance.now(); // Or get timestamp passed with ImageBitmap if needed

    // 4. Call WASM Encoder Function (adjust function name/params as needed)
    try {
        // This call is synchronous within the worker for this example.
        // For very heavy encoding, consider WASM Threads if libvpx/bindings support it.
        const encodedChunks = wasm_encoder_instance.encode_rgba_frame(frameDataBuffer, width, height, timestamp);

        // 5. Send results back to main thread
        if (encodedChunks && encodedChunks.length > 0) {
             // Example: Send each chunk individually, or batch them
            for (const chunk of encodedChunks) {
                 // Assume chunk is { data: Uint8Array, timestamp: number, duration: number|null, is_keyframe: bool }
                 // Transfer ArrayBuffer data for efficiency if possible (depends on structure)
                 // For simplicity here, we assume the WASM function returns serializable objects/data.
                 // If data is large Uint8Array, transfer its buffer:
                 // self.postMessage({ type: 'encoded_chunk', payload: chunk }, [chunk.data.buffer]);
                 self.postMessage({ type: 'encoded_chunk', payload: chunk });
             }
        }
         // Cleanup WASM memory if needed after processing chunks (depends on binding)
         if (wasm_encoder_instance.free_encoded_chunks) {
            wasm_encoder_instance.free_encoded_chunks(encodedChunks);
         }

    } catch (error) {
        logError(`WASM encoding failed: ${error}`);
    }
}

// Handle messages from the main thread
self.onmessage = async (event) => {
    const message = event.data;

    switch (message.type) {
        case 'init':
            // Initialize WASM module
            try {
                // Assuming message.payload contains { wasmBytes, memory } or similar init info
                // This setup depends heavily on how you compile/instantiate your WASM
                // Example using direct instantiation (adjust as needed):
                // wasm_encoder_module = await WebAssembly.compile(message.payload.wasmBytes);
                // const imports = { /* ... import objects ... */ };
                // wasm_encoder_instance = await WebAssembly.instantiate(wasm_encoder_module, imports);
                // --- OR using JS bindings generated by wasm-pack/bindgen ---
                wasm_encoder_instance = message.payload.wasm_bindgen_module; // If passing the instantiated module
                console.log("iOS Worker: WASM Encoder Initialized.");
                // Initialize encoder within WASM if needed
                // Example: wasm_encoder_instance.initialize_encoder(width, height, bitrate...);
                self.postMessage({ type: 'init_complete' });
            } catch (error) {
                logError(`WASM Initialization failed: ${error}`);
                self.postMessage({ type: 'init_failed', detail: error.toString() });
            }
            break;

        case 'encode_frame':
            // Received an ImageBitmap to encode
            if (message.payload instanceof ImageBitmap) {
                await processFrame(message.payload);
            } else {
                logError("Received non-ImageBitmap payload for encode_frame.");
            }
            break;

        case 'set_bitrate':
            if (wasm_encoder_instance && wasm_encoder_instance.set_bitrate) {
                try {
                    wasm_encoder_instance.set_bitrate(message.payload.bitrate);
                    console.log(`iOS Worker: Bitrate set to ${message.payload.bitrate}`);
                } catch(e) {
                    logError(`Failed to set bitrate: ${e}`);
                }
            }
            break;

        case 'request_keyframe':
             if (wasm_encoder_instance && wasm_encoder_instance.request_keyframe) {
                try {
                    wasm_encoder_instance.request_keyframe();
                    console.log(`iOS Worker: Keyframe requested`);
                } catch(e) {
                    logError(`Failed to request keyframe: ${e}`);
                }
             }
            break;

        case 'close':
             if (wasm_encoder_instance && wasm_encoder_instance.close_encoder) {
                try {
                    wasm_encoder_instance.close_encoder();
                    console.log(`iOS Worker: Encoder closed.`);
                } catch(e) {
                    logError(`Failed to close encoder: ${e}`);
                }
             }
            // Optionally terminate the worker
            // self.close();
            break;

        default:
            console.warn("iOS Worker: Received unknown message type:", message.type);
    }
};